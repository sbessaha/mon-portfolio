{"ast":null,"code":"import \"core-js/modules/es.regexp.flags.js\";\n\n/**\n* @vue/reactivity v3.5.13\n* (c) 2018-present Yuxi (Evan) You and Vue contributors\n* @license MIT\n**/\nimport { hasChanged, extend, isArray, isIntegerKey, isSymbol, isMap, hasOwn, isObject, makeMap, toRawType, capitalize, def, isFunction, EMPTY_OBJ, isSet, isPlainObject, NOOP, remove } from '@vue/shared';\n\nfunction warn(msg, ...args) {\n  console.warn(`[Vue warn] ${msg}`, ...args);\n}\n\nlet activeEffectScope;\n\nclass EffectScope {\n  constructor(detached = false) {\n    this.detached = detached;\n    /**\n     * @internal\n     */\n\n    this._active = true;\n    /**\n     * @internal\n     */\n\n    this.effects = [];\n    /**\n     * @internal\n     */\n\n    this.cleanups = [];\n    this._isPaused = false;\n    this.parent = activeEffectScope;\n\n    if (!detached && activeEffectScope) {\n      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;\n    }\n  }\n\n  get active() {\n    return this._active;\n  }\n\n  pause() {\n    if (this._active) {\n      this._isPaused = true;\n      let i, l;\n\n      if (this.scopes) {\n        for (i = 0, l = this.scopes.length; i < l; i++) {\n          this.scopes[i].pause();\n        }\n      }\n\n      for (i = 0, l = this.effects.length; i < l; i++) {\n        this.effects[i].pause();\n      }\n    }\n  }\n  /**\n   * Resumes the effect scope, including all child scopes and effects.\n   */\n\n\n  resume() {\n    if (this._active) {\n      if (this._isPaused) {\n        this._isPaused = false;\n        let i, l;\n\n        if (this.scopes) {\n          for (i = 0, l = this.scopes.length; i < l; i++) {\n            this.scopes[i].resume();\n          }\n        }\n\n        for (i = 0, l = this.effects.length; i < l; i++) {\n          this.effects[i].resume();\n        }\n      }\n    }\n  }\n\n  run(fn) {\n    if (this._active) {\n      const currentEffectScope = activeEffectScope;\n\n      try {\n        activeEffectScope = this;\n        return fn();\n      } finally {\n        activeEffectScope = currentEffectScope;\n      }\n    } else if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(`cannot run an inactive effect scope.`);\n    }\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n\n\n  on() {\n    activeEffectScope = this;\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n\n\n  off() {\n    activeEffectScope = this.parent;\n  }\n\n  stop(fromParent) {\n    if (this._active) {\n      this._active = false;\n      let i, l;\n\n      for (i = 0, l = this.effects.length; i < l; i++) {\n        this.effects[i].stop();\n      }\n\n      this.effects.length = 0;\n\n      for (i = 0, l = this.cleanups.length; i < l; i++) {\n        this.cleanups[i]();\n      }\n\n      this.cleanups.length = 0;\n\n      if (this.scopes) {\n        for (i = 0, l = this.scopes.length; i < l; i++) {\n          this.scopes[i].stop(true);\n        }\n\n        this.scopes.length = 0;\n      }\n\n      if (!this.detached && this.parent && !fromParent) {\n        const last = this.parent.scopes.pop();\n\n        if (last && last !== this) {\n          this.parent.scopes[this.index] = last;\n          last.index = this.index;\n        }\n      }\n\n      this.parent = void 0;\n    }\n  }\n\n}\n\nfunction effectScope(detached) {\n  return new EffectScope(detached);\n}\n\nfunction getCurrentScope() {\n  return activeEffectScope;\n}\n\nfunction onScopeDispose(fn, failSilently = false) {\n  if (activeEffectScope) {\n    activeEffectScope.cleanups.push(fn);\n  } else if (!!(process.env.NODE_ENV !== \"production\") && !failSilently) {\n    warn(`onScopeDispose() is called when there is no active effect scope to be associated with.`);\n  }\n}\n\nlet activeSub;\nconst EffectFlags = {\n  \"ACTIVE\": 1,\n  \"1\": \"ACTIVE\",\n  \"RUNNING\": 2,\n  \"2\": \"RUNNING\",\n  \"TRACKING\": 4,\n  \"4\": \"TRACKING\",\n  \"NOTIFIED\": 8,\n  \"8\": \"NOTIFIED\",\n  \"DIRTY\": 16,\n  \"16\": \"DIRTY\",\n  \"ALLOW_RECURSE\": 32,\n  \"32\": \"ALLOW_RECURSE\",\n  \"PAUSED\": 64,\n  \"64\": \"PAUSED\"\n};\nconst pausedQueueEffects = /* @__PURE__ */new WeakSet();\n\nclass ReactiveEffect {\n  constructor(fn) {\n    this.fn = fn;\n    /**\n     * @internal\n     */\n\n    this.deps = void 0;\n    /**\n     * @internal\n     */\n\n    this.depsTail = void 0;\n    /**\n     * @internal\n     */\n\n    this.flags = 1 | 4;\n    /**\n     * @internal\n     */\n\n    this.next = void 0;\n    /**\n     * @internal\n     */\n\n    this.cleanup = void 0;\n    this.scheduler = void 0;\n\n    if (activeEffectScope && activeEffectScope.active) {\n      activeEffectScope.effects.push(this);\n    }\n  }\n\n  pause() {\n    this.flags |= 64;\n  }\n\n  resume() {\n    if (this.flags & 64) {\n      this.flags &= ~64;\n\n      if (pausedQueueEffects.has(this)) {\n        pausedQueueEffects.delete(this);\n        this.trigger();\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n\n\n  notify() {\n    if (this.flags & 2 && !(this.flags & 32)) {\n      return;\n    }\n\n    if (!(this.flags & 8)) {\n      batch(this);\n    }\n  }\n\n  run() {\n    if (!(this.flags & 1)) {\n      return this.fn();\n    }\n\n    this.flags |= 2;\n    cleanupEffect(this);\n    prepareDeps(this);\n    const prevEffect = activeSub;\n    const prevShouldTrack = shouldTrack;\n    activeSub = this;\n    shouldTrack = true;\n\n    try {\n      return this.fn();\n    } finally {\n      if (!!(process.env.NODE_ENV !== \"production\") && activeSub !== this) {\n        warn(\"Active effect was not restored correctly - this is likely a Vue internal bug.\");\n      }\n\n      cleanupDeps(this);\n      activeSub = prevEffect;\n      shouldTrack = prevShouldTrack;\n      this.flags &= ~2;\n    }\n  }\n\n  stop() {\n    if (this.flags & 1) {\n      for (let link = this.deps; link; link = link.nextDep) {\n        removeSub(link);\n      }\n\n      this.deps = this.depsTail = void 0;\n      cleanupEffect(this);\n      this.onStop && this.onStop();\n      this.flags &= ~1;\n    }\n  }\n\n  trigger() {\n    if (this.flags & 64) {\n      pausedQueueEffects.add(this);\n    } else if (this.scheduler) {\n      this.scheduler();\n    } else {\n      this.runIfDirty();\n    }\n  }\n  /**\n   * @internal\n   */\n\n\n  runIfDirty() {\n    if (isDirty(this)) {\n      this.run();\n    }\n  }\n\n  get dirty() {\n    return isDirty(this);\n  }\n\n}\n\nlet batchDepth = 0;\nlet batchedSub;\nlet batchedComputed;\n\nfunction batch(sub, isComputed = false) {\n  sub.flags |= 8;\n\n  if (isComputed) {\n    sub.next = batchedComputed;\n    batchedComputed = sub;\n    return;\n  }\n\n  sub.next = batchedSub;\n  batchedSub = sub;\n}\n\nfunction startBatch() {\n  batchDepth++;\n}\n\nfunction endBatch() {\n  if (--batchDepth > 0) {\n    return;\n  }\n\n  if (batchedComputed) {\n    let e = batchedComputed;\n    batchedComputed = void 0;\n\n    while (e) {\n      const next = e.next;\n      e.next = void 0;\n      e.flags &= ~8;\n      e = next;\n    }\n  }\n\n  let error;\n\n  while (batchedSub) {\n    let e = batchedSub;\n    batchedSub = void 0;\n\n    while (e) {\n      const next = e.next;\n      e.next = void 0;\n      e.flags &= ~8;\n\n      if (e.flags & 1) {\n        try {\n          ;\n          e.trigger();\n        } catch (err) {\n          if (!error) error = err;\n        }\n      }\n\n      e = next;\n    }\n  }\n\n  if (error) throw error;\n}\n\nfunction prepareDeps(sub) {\n  for (let link = sub.deps; link; link = link.nextDep) {\n    link.version = -1;\n    link.prevActiveLink = link.dep.activeLink;\n    link.dep.activeLink = link;\n  }\n}\n\nfunction cleanupDeps(sub) {\n  let head;\n  let tail = sub.depsTail;\n  let link = tail;\n\n  while (link) {\n    const prev = link.prevDep;\n\n    if (link.version === -1) {\n      if (link === tail) tail = prev;\n      removeSub(link);\n      removeDep(link);\n    } else {\n      head = link;\n    }\n\n    link.dep.activeLink = link.prevActiveLink;\n    link.prevActiveLink = void 0;\n    link = prev;\n  }\n\n  sub.deps = head;\n  sub.depsTail = tail;\n}\n\nfunction isDirty(sub) {\n  for (let link = sub.deps; link; link = link.nextDep) {\n    if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {\n      return true;\n    }\n  }\n\n  if (sub._dirty) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction refreshComputed(computed) {\n  if (computed.flags & 4 && !(computed.flags & 16)) {\n    return;\n  }\n\n  computed.flags &= ~16;\n\n  if (computed.globalVersion === globalVersion) {\n    return;\n  }\n\n  computed.globalVersion = globalVersion;\n  const dep = computed.dep;\n  computed.flags |= 2;\n\n  if (dep.version > 0 && !computed.isSSR && computed.deps && !isDirty(computed)) {\n    computed.flags &= ~2;\n    return;\n  }\n\n  const prevSub = activeSub;\n  const prevShouldTrack = shouldTrack;\n  activeSub = computed;\n  shouldTrack = true;\n\n  try {\n    prepareDeps(computed);\n    const value = computed.fn(computed._value);\n\n    if (dep.version === 0 || hasChanged(value, computed._value)) {\n      computed._value = value;\n      dep.version++;\n    }\n  } catch (err) {\n    dep.version++;\n    throw err;\n  } finally {\n    activeSub = prevSub;\n    shouldTrack = prevShouldTrack;\n    cleanupDeps(computed);\n    computed.flags &= ~2;\n  }\n}\n\nfunction removeSub(link, soft = false) {\n  const {\n    dep,\n    prevSub,\n    nextSub\n  } = link;\n\n  if (prevSub) {\n    prevSub.nextSub = nextSub;\n    link.prevSub = void 0;\n  }\n\n  if (nextSub) {\n    nextSub.prevSub = prevSub;\n    link.nextSub = void 0;\n  }\n\n  if (!!(process.env.NODE_ENV !== \"production\") && dep.subsHead === link) {\n    dep.subsHead = nextSub;\n  }\n\n  if (dep.subs === link) {\n    dep.subs = prevSub;\n\n    if (!prevSub && dep.computed) {\n      dep.computed.flags &= ~4;\n\n      for (let l = dep.computed.deps; l; l = l.nextDep) {\n        removeSub(l, true);\n      }\n    }\n  }\n\n  if (!soft && ! --dep.sc && dep.map) {\n    dep.map.delete(dep.key);\n  }\n}\n\nfunction removeDep(link) {\n  const {\n    prevDep,\n    nextDep\n  } = link;\n\n  if (prevDep) {\n    prevDep.nextDep = nextDep;\n    link.prevDep = void 0;\n  }\n\n  if (nextDep) {\n    nextDep.prevDep = prevDep;\n    link.nextDep = void 0;\n  }\n}\n\nfunction effect(fn, options) {\n  if (fn.effect instanceof ReactiveEffect) {\n    fn = fn.effect.fn;\n  }\n\n  const e = new ReactiveEffect(fn);\n\n  if (options) {\n    extend(e, options);\n  }\n\n  try {\n    e.run();\n  } catch (err) {\n    e.stop();\n    throw err;\n  }\n\n  const runner = e.run.bind(e);\n  runner.effect = e;\n  return runner;\n}\n\nfunction stop(runner) {\n  runner.effect.stop();\n}\n\nlet shouldTrack = true;\nconst trackStack = [];\n\nfunction pauseTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = false;\n}\n\nfunction enableTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = true;\n}\n\nfunction resetTracking() {\n  const last = trackStack.pop();\n  shouldTrack = last === void 0 ? true : last;\n}\n\nfunction onEffectCleanup(fn, failSilently = false) {\n  if (activeSub instanceof ReactiveEffect) {\n    activeSub.cleanup = fn;\n  } else if (!!(process.env.NODE_ENV !== \"production\") && !failSilently) {\n    warn(`onEffectCleanup() was called when there was no active effect to associate with.`);\n  }\n}\n\nfunction cleanupEffect(e) {\n  const {\n    cleanup\n  } = e;\n  e.cleanup = void 0;\n\n  if (cleanup) {\n    const prevSub = activeSub;\n    activeSub = void 0;\n\n    try {\n      cleanup();\n    } finally {\n      activeSub = prevSub;\n    }\n  }\n}\n\nlet globalVersion = 0;\n\nclass Link {\n  constructor(sub, dep) {\n    this.sub = sub;\n    this.dep = dep;\n    this.version = dep.version;\n    this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;\n  }\n\n}\n\nclass Dep {\n  constructor(computed) {\n    this.computed = computed;\n    this.version = 0;\n    /**\n     * Link between this dep and the current active effect\n     */\n\n    this.activeLink = void 0;\n    /**\n     * Doubly linked list representing the subscribing effects (tail)\n     */\n\n    this.subs = void 0;\n    /**\n     * For object property deps cleanup\n     */\n\n    this.map = void 0;\n    this.key = void 0;\n    /**\n     * Subscriber counter\n     */\n\n    this.sc = 0;\n\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      this.subsHead = void 0;\n    }\n  }\n\n  track(debugInfo) {\n    if (!activeSub || !shouldTrack || activeSub === this.computed) {\n      return;\n    }\n\n    let link = this.activeLink;\n\n    if (link === void 0 || link.sub !== activeSub) {\n      link = this.activeLink = new Link(activeSub, this);\n\n      if (!activeSub.deps) {\n        activeSub.deps = activeSub.depsTail = link;\n      } else {\n        link.prevDep = activeSub.depsTail;\n        activeSub.depsTail.nextDep = link;\n        activeSub.depsTail = link;\n      }\n\n      addSub(link);\n    } else if (link.version === -1) {\n      link.version = this.version;\n\n      if (link.nextDep) {\n        const next = link.nextDep;\n        next.prevDep = link.prevDep;\n\n        if (link.prevDep) {\n          link.prevDep.nextDep = next;\n        }\n\n        link.prevDep = activeSub.depsTail;\n        link.nextDep = void 0;\n        activeSub.depsTail.nextDep = link;\n        activeSub.depsTail = link;\n\n        if (activeSub.deps === link) {\n          activeSub.deps = next;\n        }\n      }\n    }\n\n    if (!!(process.env.NODE_ENV !== \"production\") && activeSub.onTrack) {\n      activeSub.onTrack(extend({\n        effect: activeSub\n      }, debugInfo));\n    }\n\n    return link;\n  }\n\n  trigger(debugInfo) {\n    this.version++;\n    globalVersion++;\n    this.notify(debugInfo);\n  }\n\n  notify(debugInfo) {\n    startBatch();\n\n    try {\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        for (let head = this.subsHead; head; head = head.nextSub) {\n          if (head.sub.onTrigger && !(head.sub.flags & 8)) {\n            head.sub.onTrigger(extend({\n              effect: head.sub\n            }, debugInfo));\n          }\n        }\n      }\n\n      for (let link = this.subs; link; link = link.prevSub) {\n        if (link.sub.notify()) {\n          ;\n          link.sub.dep.notify();\n        }\n      }\n    } finally {\n      endBatch();\n    }\n  }\n\n}\n\nfunction addSub(link) {\n  link.dep.sc++;\n\n  if (link.sub.flags & 4) {\n    const computed = link.dep.computed;\n\n    if (computed && !link.dep.subs) {\n      computed.flags |= 4 | 16;\n\n      for (let l = computed.deps; l; l = l.nextDep) {\n        addSub(l);\n      }\n    }\n\n    const currentTail = link.dep.subs;\n\n    if (currentTail !== link) {\n      link.prevSub = currentTail;\n      if (currentTail) currentTail.nextSub = link;\n    }\n\n    if (!!(process.env.NODE_ENV !== \"production\") && link.dep.subsHead === void 0) {\n      link.dep.subsHead = link;\n    }\n\n    link.dep.subs = link;\n  }\n}\n\nconst targetMap = /* @__PURE__ */new WeakMap();\nconst ITERATE_KEY = Symbol(!!(process.env.NODE_ENV !== \"production\") ? \"Object iterate\" : \"\");\nconst MAP_KEY_ITERATE_KEY = Symbol(!!(process.env.NODE_ENV !== \"production\") ? \"Map keys iterate\" : \"\");\nconst ARRAY_ITERATE_KEY = Symbol(!!(process.env.NODE_ENV !== \"production\") ? \"Array iterate\" : \"\");\n\nfunction track(target, type, key) {\n  if (shouldTrack && activeSub) {\n    let depsMap = targetMap.get(target);\n\n    if (!depsMap) {\n      targetMap.set(target, depsMap = /* @__PURE__ */new Map());\n    }\n\n    let dep = depsMap.get(key);\n\n    if (!dep) {\n      depsMap.set(key, dep = new Dep());\n      dep.map = depsMap;\n      dep.key = key;\n    }\n\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      dep.track({\n        target,\n        type,\n        key\n      });\n    } else {\n      dep.track();\n    }\n  }\n}\n\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\n  const depsMap = targetMap.get(target);\n\n  if (!depsMap) {\n    globalVersion++;\n    return;\n  }\n\n  const run = dep => {\n    if (dep) {\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        dep.trigger({\n          target,\n          type,\n          key,\n          newValue,\n          oldValue,\n          oldTarget\n        });\n      } else {\n        dep.trigger();\n      }\n    }\n  };\n\n  startBatch();\n\n  if (type === \"clear\") {\n    depsMap.forEach(run);\n  } else {\n    const targetIsArray = isArray(target);\n    const isArrayIndex = targetIsArray && isIntegerKey(key);\n\n    if (targetIsArray && key === \"length\") {\n      const newLength = Number(newValue);\n      depsMap.forEach((dep, key2) => {\n        if (key2 === \"length\" || key2 === ARRAY_ITERATE_KEY || !isSymbol(key2) && key2 >= newLength) {\n          run(dep);\n        }\n      });\n    } else {\n      if (key !== void 0 || depsMap.has(void 0)) {\n        run(depsMap.get(key));\n      }\n\n      if (isArrayIndex) {\n        run(depsMap.get(ARRAY_ITERATE_KEY));\n      }\n\n      switch (type) {\n        case \"add\":\n          if (!targetIsArray) {\n            run(depsMap.get(ITERATE_KEY));\n\n            if (isMap(target)) {\n              run(depsMap.get(MAP_KEY_ITERATE_KEY));\n            }\n          } else if (isArrayIndex) {\n            run(depsMap.get(\"length\"));\n          }\n\n          break;\n\n        case \"delete\":\n          if (!targetIsArray) {\n            run(depsMap.get(ITERATE_KEY));\n\n            if (isMap(target)) {\n              run(depsMap.get(MAP_KEY_ITERATE_KEY));\n            }\n          }\n\n          break;\n\n        case \"set\":\n          if (isMap(target)) {\n            run(depsMap.get(ITERATE_KEY));\n          }\n\n          break;\n      }\n    }\n  }\n\n  endBatch();\n}\n\nfunction getDepFromReactive(object, key) {\n  const depMap = targetMap.get(object);\n  return depMap && depMap.get(key);\n}\n\nfunction reactiveReadArray(array) {\n  const raw = toRaw(array);\n  if (raw === array) return raw;\n  track(raw, \"iterate\", ARRAY_ITERATE_KEY);\n  return isShallow(array) ? raw : raw.map(toReactive);\n}\n\nfunction shallowReadArray(arr) {\n  track(arr = toRaw(arr), \"iterate\", ARRAY_ITERATE_KEY);\n  return arr;\n}\n\nconst arrayInstrumentations = {\n  __proto__: null,\n\n  [Symbol.iterator]() {\n    return iterator(this, Symbol.iterator, toReactive);\n  },\n\n  concat(...args) {\n    return reactiveReadArray(this).concat(...args.map(x => isArray(x) ? reactiveReadArray(x) : x));\n  },\n\n  entries() {\n    return iterator(this, \"entries\", value => {\n      value[1] = toReactive(value[1]);\n      return value;\n    });\n  },\n\n  every(fn, thisArg) {\n    return apply(this, \"every\", fn, thisArg, void 0, arguments);\n  },\n\n  filter(fn, thisArg) {\n    return apply(this, \"filter\", fn, thisArg, v => v.map(toReactive), arguments);\n  },\n\n  find(fn, thisArg) {\n    return apply(this, \"find\", fn, thisArg, toReactive, arguments);\n  },\n\n  findIndex(fn, thisArg) {\n    return apply(this, \"findIndex\", fn, thisArg, void 0, arguments);\n  },\n\n  findLast(fn, thisArg) {\n    return apply(this, \"findLast\", fn, thisArg, toReactive, arguments);\n  },\n\n  findLastIndex(fn, thisArg) {\n    return apply(this, \"findLastIndex\", fn, thisArg, void 0, arguments);\n  },\n\n  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement\n  forEach(fn, thisArg) {\n    return apply(this, \"forEach\", fn, thisArg, void 0, arguments);\n  },\n\n  includes(...args) {\n    return searchProxy(this, \"includes\", args);\n  },\n\n  indexOf(...args) {\n    return searchProxy(this, \"indexOf\", args);\n  },\n\n  join(separator) {\n    return reactiveReadArray(this).join(separator);\n  },\n\n  // keys() iterator only reads `length`, no optimisation required\n  lastIndexOf(...args) {\n    return searchProxy(this, \"lastIndexOf\", args);\n  },\n\n  map(fn, thisArg) {\n    return apply(this, \"map\", fn, thisArg, void 0, arguments);\n  },\n\n  pop() {\n    return noTracking(this, \"pop\");\n  },\n\n  push(...args) {\n    return noTracking(this, \"push\", args);\n  },\n\n  reduce(fn, ...args) {\n    return reduce(this, \"reduce\", fn, args);\n  },\n\n  reduceRight(fn, ...args) {\n    return reduce(this, \"reduceRight\", fn, args);\n  },\n\n  shift() {\n    return noTracking(this, \"shift\");\n  },\n\n  // slice could use ARRAY_ITERATE but also seems to beg for range tracking\n  some(fn, thisArg) {\n    return apply(this, \"some\", fn, thisArg, void 0, arguments);\n  },\n\n  splice(...args) {\n    return noTracking(this, \"splice\", args);\n  },\n\n  toReversed() {\n    return reactiveReadArray(this).toReversed();\n  },\n\n  toSorted(comparer) {\n    return reactiveReadArray(this).toSorted(comparer);\n  },\n\n  toSpliced(...args) {\n    return reactiveReadArray(this).toSpliced(...args);\n  },\n\n  unshift(...args) {\n    return noTracking(this, \"unshift\", args);\n  },\n\n  values() {\n    return iterator(this, \"values\", toReactive);\n  }\n\n};\n\nfunction iterator(self, method, wrapValue) {\n  const arr = shallowReadArray(self);\n  const iter = arr[method]();\n\n  if (arr !== self && !isShallow(self)) {\n    iter._next = iter.next;\n\n    iter.next = () => {\n      const result = iter._next();\n\n      if (result.value) {\n        result.value = wrapValue(result.value);\n      }\n\n      return result;\n    };\n  }\n\n  return iter;\n}\n\nconst arrayProto = Array.prototype;\n\nfunction apply(self, method, fn, thisArg, wrappedRetFn, args) {\n  const arr = shallowReadArray(self);\n  const needsWrap = arr !== self && !isShallow(self);\n  const methodFn = arr[method];\n\n  if (methodFn !== arrayProto[method]) {\n    const result2 = methodFn.apply(self, args);\n    return needsWrap ? toReactive(result2) : result2;\n  }\n\n  let wrappedFn = fn;\n\n  if (arr !== self) {\n    if (needsWrap) {\n      wrappedFn = function (item, index) {\n        return fn.call(this, toReactive(item), index, self);\n      };\n    } else if (fn.length > 2) {\n      wrappedFn = function (item, index) {\n        return fn.call(this, item, index, self);\n      };\n    }\n  }\n\n  const result = methodFn.call(arr, wrappedFn, thisArg);\n  return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;\n}\n\nfunction reduce(self, method, fn, args) {\n  const arr = shallowReadArray(self);\n  let wrappedFn = fn;\n\n  if (arr !== self) {\n    if (!isShallow(self)) {\n      wrappedFn = function (acc, item, index) {\n        return fn.call(this, acc, toReactive(item), index, self);\n      };\n    } else if (fn.length > 3) {\n      wrappedFn = function (acc, item, index) {\n        return fn.call(this, acc, item, index, self);\n      };\n    }\n  }\n\n  return arr[method](wrappedFn, ...args);\n}\n\nfunction searchProxy(self, method, args) {\n  const arr = toRaw(self);\n  track(arr, \"iterate\", ARRAY_ITERATE_KEY);\n  const res = arr[method](...args);\n\n  if ((res === -1 || res === false) && isProxy(args[0])) {\n    args[0] = toRaw(args[0]);\n    return arr[method](...args);\n  }\n\n  return res;\n}\n\nfunction noTracking(self, method, args = []) {\n  pauseTracking();\n  startBatch();\n  const res = toRaw(self)[method].apply(self, args);\n  endBatch();\n  resetTracking();\n  return res;\n}\n\nconst isNonTrackableKeys = /* @__PURE__ */makeMap(`__proto__,__v_isRef,__isVue`);\nconst builtInSymbols = new Set( /* @__PURE__ */Object.getOwnPropertyNames(Symbol).filter(key => key !== \"arguments\" && key !== \"caller\").map(key => Symbol[key]).filter(isSymbol));\n\nfunction hasOwnProperty(key) {\n  if (!isSymbol(key)) key = String(key);\n  const obj = toRaw(this);\n  track(obj, \"has\", key);\n  return obj.hasOwnProperty(key);\n}\n\nclass BaseReactiveHandler {\n  constructor(_isReadonly = false, _isShallow = false) {\n    this._isReadonly = _isReadonly;\n    this._isShallow = _isShallow;\n  }\n\n  get(target, key, receiver) {\n    if (key === \"__v_skip\") return target[\"__v_skip\"];\n    const isReadonly2 = this._isReadonly,\n          isShallow2 = this._isShallow;\n\n    if (key === \"__v_isReactive\") {\n      return !isReadonly2;\n    } else if (key === \"__v_isReadonly\") {\n      return isReadonly2;\n    } else if (key === \"__v_isShallow\") {\n      return isShallow2;\n    } else if (key === \"__v_raw\") {\n      if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype\n      // this means the receiver is a user proxy of the reactive proxy\n      Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {\n        return target;\n      }\n\n      return;\n    }\n\n    const targetIsArray = isArray(target);\n\n    if (!isReadonly2) {\n      let fn;\n\n      if (targetIsArray && (fn = arrayInstrumentations[key])) {\n        return fn;\n      }\n\n      if (key === \"hasOwnProperty\") {\n        return hasOwnProperty;\n      }\n    }\n\n    const res = Reflect.get(target, key, // if this is a proxy wrapping a ref, return methods using the raw ref\n    // as receiver so that we don't have to call `toRaw` on the ref in all\n    // its class methods\n    isRef(target) ? target : receiver);\n\n    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n      return res;\n    }\n\n    if (!isReadonly2) {\n      track(target, \"get\", key);\n    }\n\n    if (isShallow2) {\n      return res;\n    }\n\n    if (isRef(res)) {\n      return targetIsArray && isIntegerKey(key) ? res : res.value;\n    }\n\n    if (isObject(res)) {\n      return isReadonly2 ? readonly(res) : reactive(res);\n    }\n\n    return res;\n  }\n\n}\n\nclass MutableReactiveHandler extends BaseReactiveHandler {\n  constructor(isShallow2 = false) {\n    super(false, isShallow2);\n  }\n\n  set(target, key, value, receiver) {\n    let oldValue = target[key];\n\n    if (!this._isShallow) {\n      const isOldValueReadonly = isReadonly(oldValue);\n\n      if (!isShallow(value) && !isReadonly(value)) {\n        oldValue = toRaw(oldValue);\n        value = toRaw(value);\n      }\n\n      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\n        if (isOldValueReadonly) {\n          return false;\n        } else {\n          oldValue.value = value;\n          return true;\n        }\n      }\n    }\n\n    const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);\n    const result = Reflect.set(target, key, value, isRef(target) ? target : receiver);\n\n    if (target === toRaw(receiver)) {\n      if (!hadKey) {\n        trigger(target, \"add\", key, value);\n      } else if (hasChanged(value, oldValue)) {\n        trigger(target, \"set\", key, value, oldValue);\n      }\n    }\n\n    return result;\n  }\n\n  deleteProperty(target, key) {\n    const hadKey = hasOwn(target, key);\n    const oldValue = target[key];\n    const result = Reflect.deleteProperty(target, key);\n\n    if (result && hadKey) {\n      trigger(target, \"delete\", key, void 0, oldValue);\n    }\n\n    return result;\n  }\n\n  has(target, key) {\n    const result = Reflect.has(target, key);\n\n    if (!isSymbol(key) || !builtInSymbols.has(key)) {\n      track(target, \"has\", key);\n    }\n\n    return result;\n  }\n\n  ownKeys(target) {\n    track(target, \"iterate\", isArray(target) ? \"length\" : ITERATE_KEY);\n    return Reflect.ownKeys(target);\n  }\n\n}\n\nclass ReadonlyReactiveHandler extends BaseReactiveHandler {\n  constructor(isShallow2 = false) {\n    super(true, isShallow2);\n  }\n\n  set(target, key) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(`Set operation on key \"${String(key)}\" failed: target is readonly.`, target);\n    }\n\n    return true;\n  }\n\n  deleteProperty(target, key) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(`Delete operation on key \"${String(key)}\" failed: target is readonly.`, target);\n    }\n\n    return true;\n  }\n\n}\n\nconst mutableHandlers = /* @__PURE__ */new MutableReactiveHandler();\nconst readonlyHandlers = /* @__PURE__ */new ReadonlyReactiveHandler();\nconst shallowReactiveHandlers = /* @__PURE__ */new MutableReactiveHandler(true);\nconst shallowReadonlyHandlers = /* @__PURE__ */new ReadonlyReactiveHandler(true);\n\nconst toShallow = value => value;\n\nconst getProto = v => Reflect.getPrototypeOf(v);\n\nfunction createIterableMethod(method, isReadonly2, isShallow2) {\n  return function (...args) {\n    const target = this[\"__v_raw\"];\n    const rawTarget = toRaw(target);\n    const targetIsMap = isMap(rawTarget);\n    const isPair = method === \"entries\" || method === Symbol.iterator && targetIsMap;\n    const isKeyOnly = method === \"keys\" && targetIsMap;\n    const innerIterator = target[method](...args);\n    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;\n    !isReadonly2 && track(rawTarget, \"iterate\", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);\n    return {\n      // iterator protocol\n      next() {\n        const {\n          value,\n          done\n        } = innerIterator.next();\n        return done ? {\n          value,\n          done\n        } : {\n          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n          done\n        };\n      },\n\n      // iterable protocol\n      [Symbol.iterator]() {\n        return this;\n      }\n\n    };\n  };\n}\n\nfunction createReadonlyMethod(type) {\n  return function (...args) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      const key = args[0] ? `on key \"${args[0]}\" ` : ``;\n      warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));\n    }\n\n    return type === \"delete\" ? false : type === \"clear\" ? void 0 : this;\n  };\n}\n\nfunction createInstrumentations(readonly, shallow) {\n  const instrumentations = {\n    get(key) {\n      const target = this[\"__v_raw\"];\n      const rawTarget = toRaw(target);\n      const rawKey = toRaw(key);\n\n      if (!readonly) {\n        if (hasChanged(key, rawKey)) {\n          track(rawTarget, \"get\", key);\n        }\n\n        track(rawTarget, \"get\", rawKey);\n      }\n\n      const {\n        has\n      } = getProto(rawTarget);\n      const wrap = shallow ? toShallow : readonly ? toReadonly : toReactive;\n\n      if (has.call(rawTarget, key)) {\n        return wrap(target.get(key));\n      } else if (has.call(rawTarget, rawKey)) {\n        return wrap(target.get(rawKey));\n      } else if (target !== rawTarget) {\n        target.get(key);\n      }\n    },\n\n    get size() {\n      const target = this[\"__v_raw\"];\n      !readonly && track(toRaw(target), \"iterate\", ITERATE_KEY);\n      return Reflect.get(target, \"size\", target);\n    },\n\n    has(key) {\n      const target = this[\"__v_raw\"];\n      const rawTarget = toRaw(target);\n      const rawKey = toRaw(key);\n\n      if (!readonly) {\n        if (hasChanged(key, rawKey)) {\n          track(rawTarget, \"has\", key);\n        }\n\n        track(rawTarget, \"has\", rawKey);\n      }\n\n      return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);\n    },\n\n    forEach(callback, thisArg) {\n      const observed = this;\n      const target = observed[\"__v_raw\"];\n      const rawTarget = toRaw(target);\n      const wrap = shallow ? toShallow : readonly ? toReadonly : toReactive;\n      !readonly && track(rawTarget, \"iterate\", ITERATE_KEY);\n      return target.forEach((value, key) => {\n        return callback.call(thisArg, wrap(value), wrap(key), observed);\n      });\n    }\n\n  };\n  extend(instrumentations, readonly ? {\n    add: createReadonlyMethod(\"add\"),\n    set: createReadonlyMethod(\"set\"),\n    delete: createReadonlyMethod(\"delete\"),\n    clear: createReadonlyMethod(\"clear\")\n  } : {\n    add(value) {\n      if (!shallow && !isShallow(value) && !isReadonly(value)) {\n        value = toRaw(value);\n      }\n\n      const target = toRaw(this);\n      const proto = getProto(target);\n      const hadKey = proto.has.call(target, value);\n\n      if (!hadKey) {\n        target.add(value);\n        trigger(target, \"add\", value, value);\n      }\n\n      return this;\n    },\n\n    set(key, value) {\n      if (!shallow && !isShallow(value) && !isReadonly(value)) {\n        value = toRaw(value);\n      }\n\n      const target = toRaw(this);\n      const {\n        has,\n        get\n      } = getProto(target);\n      let hadKey = has.call(target, key);\n\n      if (!hadKey) {\n        key = toRaw(key);\n        hadKey = has.call(target, key);\n      } else if (!!(process.env.NODE_ENV !== \"production\")) {\n        checkIdentityKeys(target, has, key);\n      }\n\n      const oldValue = get.call(target, key);\n      target.set(key, value);\n\n      if (!hadKey) {\n        trigger(target, \"add\", key, value);\n      } else if (hasChanged(value, oldValue)) {\n        trigger(target, \"set\", key, value, oldValue);\n      }\n\n      return this;\n    },\n\n    delete(key) {\n      const target = toRaw(this);\n      const {\n        has,\n        get\n      } = getProto(target);\n      let hadKey = has.call(target, key);\n\n      if (!hadKey) {\n        key = toRaw(key);\n        hadKey = has.call(target, key);\n      } else if (!!(process.env.NODE_ENV !== \"production\")) {\n        checkIdentityKeys(target, has, key);\n      }\n\n      const oldValue = get ? get.call(target, key) : void 0;\n      const result = target.delete(key);\n\n      if (hadKey) {\n        trigger(target, \"delete\", key, void 0, oldValue);\n      }\n\n      return result;\n    },\n\n    clear() {\n      const target = toRaw(this);\n      const hadItems = target.size !== 0;\n      const oldTarget = !!(process.env.NODE_ENV !== \"production\") ? isMap(target) ? new Map(target) : new Set(target) : void 0;\n      const result = target.clear();\n\n      if (hadItems) {\n        trigger(target, \"clear\", void 0, void 0, oldTarget);\n      }\n\n      return result;\n    }\n\n  });\n  const iteratorMethods = [\"keys\", \"values\", \"entries\", Symbol.iterator];\n  iteratorMethods.forEach(method => {\n    instrumentations[method] = createIterableMethod(method, readonly, shallow);\n  });\n  return instrumentations;\n}\n\nfunction createInstrumentationGetter(isReadonly2, shallow) {\n  const instrumentations = createInstrumentations(isReadonly2, shallow);\n  return (target, key, receiver) => {\n    if (key === \"__v_isReactive\") {\n      return !isReadonly2;\n    } else if (key === \"__v_isReadonly\") {\n      return isReadonly2;\n    } else if (key === \"__v_raw\") {\n      return target;\n    }\n\n    return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);\n  };\n}\n\nconst mutableCollectionHandlers = {\n  get: /* @__PURE__ */createInstrumentationGetter(false, false)\n};\nconst shallowCollectionHandlers = {\n  get: /* @__PURE__ */createInstrumentationGetter(false, true)\n};\nconst readonlyCollectionHandlers = {\n  get: /* @__PURE__ */createInstrumentationGetter(true, false)\n};\nconst shallowReadonlyCollectionHandlers = {\n  get: /* @__PURE__ */createInstrumentationGetter(true, true)\n};\n\nfunction checkIdentityKeys(target, has, key) {\n  const rawKey = toRaw(key);\n\n  if (rawKey !== key && has.call(target, rawKey)) {\n    const type = toRawType(target);\n    warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);\n  }\n}\n\nconst reactiveMap = /* @__PURE__ */new WeakMap();\nconst shallowReactiveMap = /* @__PURE__ */new WeakMap();\nconst readonlyMap = /* @__PURE__ */new WeakMap();\nconst shallowReadonlyMap = /* @__PURE__ */new WeakMap();\n\nfunction targetTypeMap(rawType) {\n  switch (rawType) {\n    case \"Object\":\n    case \"Array\":\n      return 1\n      /* COMMON */\n      ;\n\n    case \"Map\":\n    case \"Set\":\n    case \"WeakMap\":\n    case \"WeakSet\":\n      return 2\n      /* COLLECTION */\n      ;\n\n    default:\n      return 0\n      /* INVALID */\n      ;\n  }\n}\n\nfunction getTargetType(value) {\n  return value[\"__v_skip\"] || !Object.isExtensible(value) ? 0\n  /* INVALID */\n  : targetTypeMap(toRawType(value));\n}\n\nfunction reactive(target) {\n  if (isReadonly(target)) {\n    return target;\n  }\n\n  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);\n}\n\nfunction shallowReactive(target) {\n  return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);\n}\n\nfunction readonly(target) {\n  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);\n}\n\nfunction shallowReadonly(target) {\n  return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);\n}\n\nfunction createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {\n  if (!isObject(target)) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(`value cannot be made ${isReadonly2 ? \"readonly\" : \"reactive\"}: ${String(target)}`);\n    }\n\n    return target;\n  }\n\n  if (target[\"__v_raw\"] && !(isReadonly2 && target[\"__v_isReactive\"])) {\n    return target;\n  }\n\n  const existingProxy = proxyMap.get(target);\n\n  if (existingProxy) {\n    return existingProxy;\n  }\n\n  const targetType = getTargetType(target);\n\n  if (targetType === 0\n  /* INVALID */\n  ) {\n    return target;\n  }\n\n  const proxy = new Proxy(target, targetType === 2\n  /* COLLECTION */\n  ? collectionHandlers : baseHandlers);\n  proxyMap.set(target, proxy);\n  return proxy;\n}\n\nfunction isReactive(value) {\n  if (isReadonly(value)) {\n    return isReactive(value[\"__v_raw\"]);\n  }\n\n  return !!(value && value[\"__v_isReactive\"]);\n}\n\nfunction isReadonly(value) {\n  return !!(value && value[\"__v_isReadonly\"]);\n}\n\nfunction isShallow(value) {\n  return !!(value && value[\"__v_isShallow\"]);\n}\n\nfunction isProxy(value) {\n  return value ? !!value[\"__v_raw\"] : false;\n}\n\nfunction toRaw(observed) {\n  const raw = observed && observed[\"__v_raw\"];\n  return raw ? toRaw(raw) : observed;\n}\n\nfunction markRaw(value) {\n  if (!hasOwn(value, \"__v_skip\") && Object.isExtensible(value)) {\n    def(value, \"__v_skip\", true);\n  }\n\n  return value;\n}\n\nconst toReactive = value => isObject(value) ? reactive(value) : value;\n\nconst toReadonly = value => isObject(value) ? readonly(value) : value;\n\nfunction isRef(r) {\n  return r ? r[\"__v_isRef\"] === true : false;\n}\n\nfunction ref(value) {\n  return createRef(value, false);\n}\n\nfunction shallowRef(value) {\n  return createRef(value, true);\n}\n\nfunction createRef(rawValue, shallow) {\n  if (isRef(rawValue)) {\n    return rawValue;\n  }\n\n  return new RefImpl(rawValue, shallow);\n}\n\nclass RefImpl {\n  constructor(value, isShallow2) {\n    this.dep = new Dep();\n    this[\"__v_isRef\"] = true;\n    this[\"__v_isShallow\"] = false;\n    this._rawValue = isShallow2 ? value : toRaw(value);\n    this._value = isShallow2 ? value : toReactive(value);\n    this[\"__v_isShallow\"] = isShallow2;\n  }\n\n  get value() {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      this.dep.track({\n        target: this,\n        type: \"get\",\n        key: \"value\"\n      });\n    } else {\n      this.dep.track();\n    }\n\n    return this._value;\n  }\n\n  set value(newValue) {\n    const oldValue = this._rawValue;\n    const useDirectValue = this[\"__v_isShallow\"] || isShallow(newValue) || isReadonly(newValue);\n    newValue = useDirectValue ? newValue : toRaw(newValue);\n\n    if (hasChanged(newValue, oldValue)) {\n      this._rawValue = newValue;\n      this._value = useDirectValue ? newValue : toReactive(newValue);\n\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        this.dep.trigger({\n          target: this,\n          type: \"set\",\n          key: \"value\",\n          newValue,\n          oldValue\n        });\n      } else {\n        this.dep.trigger();\n      }\n    }\n  }\n\n}\n\nfunction triggerRef(ref2) {\n  if (ref2.dep) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      ref2.dep.trigger({\n        target: ref2,\n        type: \"set\",\n        key: \"value\",\n        newValue: ref2._value\n      });\n    } else {\n      ref2.dep.trigger();\n    }\n  }\n}\n\nfunction unref(ref2) {\n  return isRef(ref2) ? ref2.value : ref2;\n}\n\nfunction toValue(source) {\n  return isFunction(source) ? source() : unref(source);\n}\n\nconst shallowUnwrapHandlers = {\n  get: (target, key, receiver) => key === \"__v_raw\" ? target : unref(Reflect.get(target, key, receiver)),\n  set: (target, key, value, receiver) => {\n    const oldValue = target[key];\n\n    if (isRef(oldValue) && !isRef(value)) {\n      oldValue.value = value;\n      return true;\n    } else {\n      return Reflect.set(target, key, value, receiver);\n    }\n  }\n};\n\nfunction proxyRefs(objectWithRefs) {\n  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);\n}\n\nclass CustomRefImpl {\n  constructor(factory) {\n    this[\"__v_isRef\"] = true;\n    this._value = void 0;\n    const dep = this.dep = new Dep();\n    const {\n      get,\n      set\n    } = factory(dep.track.bind(dep), dep.trigger.bind(dep));\n    this._get = get;\n    this._set = set;\n  }\n\n  get value() {\n    return this._value = this._get();\n  }\n\n  set value(newVal) {\n    this._set(newVal);\n  }\n\n}\n\nfunction customRef(factory) {\n  return new CustomRefImpl(factory);\n}\n\nfunction toRefs(object) {\n  if (!!(process.env.NODE_ENV !== \"production\") && !isProxy(object)) {\n    warn(`toRefs() expects a reactive object but received a plain one.`);\n  }\n\n  const ret = isArray(object) ? new Array(object.length) : {};\n\n  for (const key in object) {\n    ret[key] = propertyToRef(object, key);\n  }\n\n  return ret;\n}\n\nclass ObjectRefImpl {\n  constructor(_object, _key, _defaultValue) {\n    this._object = _object;\n    this._key = _key;\n    this._defaultValue = _defaultValue;\n    this[\"__v_isRef\"] = true;\n    this._value = void 0;\n  }\n\n  get value() {\n    const val = this._object[this._key];\n    return this._value = val === void 0 ? this._defaultValue : val;\n  }\n\n  set value(newVal) {\n    this._object[this._key] = newVal;\n  }\n\n  get dep() {\n    return getDepFromReactive(toRaw(this._object), this._key);\n  }\n\n}\n\nclass GetterRefImpl {\n  constructor(_getter) {\n    this._getter = _getter;\n    this[\"__v_isRef\"] = true;\n    this[\"__v_isReadonly\"] = true;\n    this._value = void 0;\n  }\n\n  get value() {\n    return this._value = this._getter();\n  }\n\n}\n\nfunction toRef(source, key, defaultValue) {\n  if (isRef(source)) {\n    return source;\n  } else if (isFunction(source)) {\n    return new GetterRefImpl(source);\n  } else if (isObject(source) && arguments.length > 1) {\n    return propertyToRef(source, key, defaultValue);\n  } else {\n    return ref(source);\n  }\n}\n\nfunction propertyToRef(source, key, defaultValue) {\n  const val = source[key];\n  return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);\n}\n\nclass ComputedRefImpl {\n  constructor(fn, setter, isSSR) {\n    this.fn = fn;\n    this.setter = setter;\n    /**\n     * @internal\n     */\n\n    this._value = void 0;\n    /**\n     * @internal\n     */\n\n    this.dep = new Dep(this);\n    /**\n     * @internal\n     */\n\n    this.__v_isRef = true; // TODO isolatedDeclarations \"__v_isReadonly\"\n    // A computed is also a subscriber that tracks other deps\n\n    /**\n     * @internal\n     */\n\n    this.deps = void 0;\n    /**\n     * @internal\n     */\n\n    this.depsTail = void 0;\n    /**\n     * @internal\n     */\n\n    this.flags = 16;\n    /**\n     * @internal\n     */\n\n    this.globalVersion = globalVersion - 1;\n    /**\n     * @internal\n     */\n\n    this.next = void 0; // for backwards compat\n\n    this.effect = this;\n    this[\"__v_isReadonly\"] = !setter;\n    this.isSSR = isSSR;\n  }\n  /**\n   * @internal\n   */\n\n\n  notify() {\n    this.flags |= 16;\n\n    if (!(this.flags & 8) && // avoid infinite self recursion\n    activeSub !== this) {\n      batch(this, true);\n      return true;\n    } else if (!!(process.env.NODE_ENV !== \"production\")) ;\n  }\n\n  get value() {\n    const link = !!(process.env.NODE_ENV !== \"production\") ? this.dep.track({\n      target: this,\n      type: \"get\",\n      key: \"value\"\n    }) : this.dep.track();\n    refreshComputed(this);\n\n    if (link) {\n      link.version = this.dep.version;\n    }\n\n    return this._value;\n  }\n\n  set value(newValue) {\n    if (this.setter) {\n      this.setter(newValue);\n    } else if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(\"Write operation failed: computed value is readonly\");\n    }\n  }\n\n}\n\nfunction computed(getterOrOptions, debugOptions, isSSR = false) {\n  let getter;\n  let setter;\n\n  if (isFunction(getterOrOptions)) {\n    getter = getterOrOptions;\n  } else {\n    getter = getterOrOptions.get;\n    setter = getterOrOptions.set;\n  }\n\n  const cRef = new ComputedRefImpl(getter, setter, isSSR);\n\n  if (!!(process.env.NODE_ENV !== \"production\") && debugOptions && !isSSR) {\n    cRef.onTrack = debugOptions.onTrack;\n    cRef.onTrigger = debugOptions.onTrigger;\n  }\n\n  return cRef;\n}\n\nconst TrackOpTypes = {\n  \"GET\": \"get\",\n  \"HAS\": \"has\",\n  \"ITERATE\": \"iterate\"\n};\nconst TriggerOpTypes = {\n  \"SET\": \"set\",\n  \"ADD\": \"add\",\n  \"DELETE\": \"delete\",\n  \"CLEAR\": \"clear\"\n};\nconst ReactiveFlags = {\n  \"SKIP\": \"__v_skip\",\n  \"IS_REACTIVE\": \"__v_isReactive\",\n  \"IS_READONLY\": \"__v_isReadonly\",\n  \"IS_SHALLOW\": \"__v_isShallow\",\n  \"RAW\": \"__v_raw\",\n  \"IS_REF\": \"__v_isRef\"\n};\nconst WatchErrorCodes = {\n  \"WATCH_GETTER\": 2,\n  \"2\": \"WATCH_GETTER\",\n  \"WATCH_CALLBACK\": 3,\n  \"3\": \"WATCH_CALLBACK\",\n  \"WATCH_CLEANUP\": 4,\n  \"4\": \"WATCH_CLEANUP\"\n};\nconst INITIAL_WATCHER_VALUE = {};\nconst cleanupMap = /* @__PURE__ */new WeakMap();\nlet activeWatcher = void 0;\n\nfunction getCurrentWatcher() {\n  return activeWatcher;\n}\n\nfunction onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {\n  if (owner) {\n    let cleanups = cleanupMap.get(owner);\n    if (!cleanups) cleanupMap.set(owner, cleanups = []);\n    cleanups.push(cleanupFn);\n  } else if (!!(process.env.NODE_ENV !== \"production\") && !failSilently) {\n    warn(`onWatcherCleanup() was called when there was no active watcher to associate with.`);\n  }\n}\n\nfunction watch(source, cb, options = EMPTY_OBJ) {\n  const {\n    immediate,\n    deep,\n    once,\n    scheduler,\n    augmentJob,\n    call\n  } = options;\n\n  const warnInvalidSource = s => {\n    (options.onWarn || warn)(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`);\n  };\n\n  const reactiveGetter = source2 => {\n    if (deep) return source2;\n    if (isShallow(source2) || deep === false || deep === 0) return traverse(source2, 1);\n    return traverse(source2);\n  };\n\n  let effect;\n  let getter;\n  let cleanup;\n  let boundCleanup;\n  let forceTrigger = false;\n  let isMultiSource = false;\n\n  if (isRef(source)) {\n    getter = () => source.value;\n\n    forceTrigger = isShallow(source);\n  } else if (isReactive(source)) {\n    getter = () => reactiveGetter(source);\n\n    forceTrigger = true;\n  } else if (isArray(source)) {\n    isMultiSource = true;\n    forceTrigger = source.some(s => isReactive(s) || isShallow(s));\n\n    getter = () => source.map(s => {\n      if (isRef(s)) {\n        return s.value;\n      } else if (isReactive(s)) {\n        return reactiveGetter(s);\n      } else if (isFunction(s)) {\n        return call ? call(s, 2) : s();\n      } else {\n        !!(process.env.NODE_ENV !== \"production\") && warnInvalidSource(s);\n      }\n    });\n  } else if (isFunction(source)) {\n    if (cb) {\n      getter = call ? () => call(source, 2) : source;\n    } else {\n      getter = () => {\n        if (cleanup) {\n          pauseTracking();\n\n          try {\n            cleanup();\n          } finally {\n            resetTracking();\n          }\n        }\n\n        const currentEffect = activeWatcher;\n        activeWatcher = effect;\n\n        try {\n          return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);\n        } finally {\n          activeWatcher = currentEffect;\n        }\n      };\n    }\n  } else {\n    getter = NOOP;\n    !!(process.env.NODE_ENV !== \"production\") && warnInvalidSource(source);\n  }\n\n  if (cb && deep) {\n    const baseGetter = getter;\n    const depth = deep === true ? Infinity : deep;\n\n    getter = () => traverse(baseGetter(), depth);\n  }\n\n  const scope = getCurrentScope();\n\n  const watchHandle = () => {\n    effect.stop();\n\n    if (scope && scope.active) {\n      remove(scope.effects, effect);\n    }\n  };\n\n  if (once && cb) {\n    const _cb = cb;\n\n    cb = (...args) => {\n      _cb(...args);\n\n      watchHandle();\n    };\n  }\n\n  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;\n\n  const job = immediateFirstRun => {\n    if (!(effect.flags & 1) || !effect.dirty && !immediateFirstRun) {\n      return;\n    }\n\n    if (cb) {\n      const newValue = effect.run();\n\n      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue))) {\n        if (cleanup) {\n          cleanup();\n        }\n\n        const currentWatcher = activeWatcher;\n        activeWatcher = effect;\n\n        try {\n          const args = [newValue, // pass undefined as the old value when it's changed for the first time\n          oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue, boundCleanup];\n          call ? call(cb, 3, args) : // @ts-expect-error\n          cb(...args);\n          oldValue = newValue;\n        } finally {\n          activeWatcher = currentWatcher;\n        }\n      }\n    } else {\n      effect.run();\n    }\n  };\n\n  if (augmentJob) {\n    augmentJob(job);\n  }\n\n  effect = new ReactiveEffect(getter);\n  effect.scheduler = scheduler ? () => scheduler(job, false) : job;\n\n  boundCleanup = fn => onWatcherCleanup(fn, false, effect);\n\n  cleanup = effect.onStop = () => {\n    const cleanups = cleanupMap.get(effect);\n\n    if (cleanups) {\n      if (call) {\n        call(cleanups, 4);\n      } else {\n        for (const cleanup2 of cleanups) cleanup2();\n      }\n\n      cleanupMap.delete(effect);\n    }\n  };\n\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    effect.onTrack = options.onTrack;\n    effect.onTrigger = options.onTrigger;\n  }\n\n  if (cb) {\n    if (immediate) {\n      job(true);\n    } else {\n      oldValue = effect.run();\n    }\n  } else if (scheduler) {\n    scheduler(job.bind(null, true), true);\n  } else {\n    effect.run();\n  }\n\n  watchHandle.pause = effect.pause.bind(effect);\n  watchHandle.resume = effect.resume.bind(effect);\n  watchHandle.stop = watchHandle;\n  return watchHandle;\n}\n\nfunction traverse(value, depth = Infinity, seen) {\n  if (depth <= 0 || !isObject(value) || value[\"__v_skip\"]) {\n    return value;\n  }\n\n  seen = seen || /* @__PURE__ */new Set();\n\n  if (seen.has(value)) {\n    return value;\n  }\n\n  seen.add(value);\n  depth--;\n\n  if (isRef(value)) {\n    traverse(value.value, depth, seen);\n  } else if (isArray(value)) {\n    for (let i = 0; i < value.length; i++) {\n      traverse(value[i], depth, seen);\n    }\n  } else if (isSet(value) || isMap(value)) {\n    value.forEach(v => {\n      traverse(v, depth, seen);\n    });\n  } else if (isPlainObject(value)) {\n    for (const key in value) {\n      traverse(value[key], depth, seen);\n    }\n\n    for (const key of Object.getOwnPropertySymbols(value)) {\n      if (Object.prototype.propertyIsEnumerable.call(value, key)) {\n        traverse(value[key], depth, seen);\n      }\n    }\n  }\n\n  return value;\n}\n\nexport { ARRAY_ITERATE_KEY, EffectFlags, EffectScope, ITERATE_KEY, MAP_KEY_ITERATE_KEY, ReactiveEffect, ReactiveFlags, TrackOpTypes, TriggerOpTypes, WatchErrorCodes, computed, customRef, effect, effectScope, enableTracking, getCurrentScope, getCurrentWatcher, isProxy, isReactive, isReadonly, isRef, isShallow, markRaw, onEffectCleanup, onScopeDispose, onWatcherCleanup, pauseTracking, proxyRefs, reactive, reactiveReadArray, readonly, ref, resetTracking, shallowReactive, shallowReadArray, shallowReadonly, shallowRef, stop, toRaw, toReactive, toReadonly, toRef, toRefs, toValue, track, traverse, trigger, triggerRef, unref, watch };","map":{"version":3,"names":["hasChanged","extend","isArray","isIntegerKey","isSymbol","isMap","hasOwn","isObject","makeMap","toRawType","capitalize","def","isFunction","EMPTY_OBJ","isSet","isPlainObject","NOOP","remove","warn","msg","args","console","activeEffectScope","EffectScope","constructor","detached","_active","effects","cleanups","_isPaused","parent","index","scopes","push","active","pause","i","l","length","resume","run","fn","currentEffectScope","process","env","NODE_ENV","on","off","stop","fromParent","last","pop","effectScope","getCurrentScope","onScopeDispose","failSilently","activeSub","EffectFlags","pausedQueueEffects","WeakSet","ReactiveEffect","deps","depsTail","flags","next","cleanup","scheduler","has","delete","trigger","notify","batch","cleanupEffect","prepareDeps","prevEffect","prevShouldTrack","shouldTrack","cleanupDeps","link","nextDep","removeSub","onStop","add","runIfDirty","isDirty","dirty","batchDepth","batchedSub","batchedComputed","sub","isComputed","startBatch","endBatch","e","error","err","version","prevActiveLink","dep","activeLink","head","tail","prev","prevDep","removeDep","computed","refreshComputed","_dirty","globalVersion","isSSR","prevSub","value","_value","soft","nextSub","subsHead","subs","sc","map","key","effect","options","runner","bind","trackStack","pauseTracking","enableTracking","resetTracking","onEffectCleanup","Link","Dep","track","debugInfo","addSub","onTrack","onTrigger","currentTail","targetMap","WeakMap","ITERATE_KEY","Symbol","MAP_KEY_ITERATE_KEY","ARRAY_ITERATE_KEY","target","type","depsMap","get","set","Map","newValue","oldValue","oldTarget","forEach","targetIsArray","isArrayIndex","newLength","Number","key2","getDepFromReactive","object","depMap","reactiveReadArray","array","raw","toRaw","isShallow","toReactive","shallowReadArray","arr","arrayInstrumentations","__proto__","iterator","concat","x","entries","every","thisArg","apply","arguments","filter","v","find","findIndex","findLast","findLastIndex","includes","searchProxy","indexOf","join","separator","lastIndexOf","noTracking","reduce","reduceRight","shift","some","splice","toReversed","toSorted","comparer","toSpliced","unshift","values","self","method","wrapValue","iter","_next","result","arrayProto","Array","prototype","wrappedRetFn","needsWrap","methodFn","result2","wrappedFn","item","call","acc","res","isProxy","isNonTrackableKeys","builtInSymbols","Set","Object","getOwnPropertyNames","hasOwnProperty","String","obj","BaseReactiveHandler","_isReadonly","_isShallow","receiver","isReadonly2","isShallow2","shallowReadonlyMap","readonlyMap","shallowReactiveMap","reactiveMap","getPrototypeOf","Reflect","isRef","readonly","reactive","MutableReactiveHandler","isOldValueReadonly","isReadonly","hadKey","deleteProperty","ownKeys","ReadonlyReactiveHandler","mutableHandlers","readonlyHandlers","shallowReactiveHandlers","shallowReadonlyHandlers","toShallow","getProto","createIterableMethod","rawTarget","targetIsMap","isPair","isKeyOnly","innerIterator","wrap","toReadonly","done","createReadonlyMethod","createInstrumentations","shallow","instrumentations","rawKey","size","callback","observed","clear","proto","checkIdentityKeys","hadItems","iteratorMethods","createInstrumentationGetter","mutableCollectionHandlers","shallowCollectionHandlers","readonlyCollectionHandlers","shallowReadonlyCollectionHandlers","targetTypeMap","rawType","getTargetType","isExtensible","createReactiveObject","shallowReactive","shallowReadonly","baseHandlers","collectionHandlers","proxyMap","existingProxy","targetType","proxy","Proxy","isReactive","markRaw","r","ref","createRef","shallowRef","rawValue","RefImpl","_rawValue","useDirectValue","triggerRef","ref2","unref","toValue","source","shallowUnwrapHandlers","proxyRefs","objectWithRefs","CustomRefImpl","factory","_get","_set","newVal","customRef","toRefs","ret","propertyToRef","ObjectRefImpl","_object","_key","_defaultValue","val","GetterRefImpl","_getter","toRef","defaultValue","ComputedRefImpl","setter","__v_isRef","getterOrOptions","debugOptions","getter","cRef","TrackOpTypes","TriggerOpTypes","ReactiveFlags","WatchErrorCodes","INITIAL_WATCHER_VALUE","cleanupMap","activeWatcher","getCurrentWatcher","onWatcherCleanup","cleanupFn","owner","watch","cb","immediate","deep","once","augmentJob","warnInvalidSource","s","onWarn","reactiveGetter","source2","traverse","boundCleanup","forceTrigger","isMultiSource","currentEffect","baseGetter","depth","Infinity","scope","watchHandle","_cb","fill","job","immediateFirstRun","currentWatcher","cleanup2","seen","getOwnPropertySymbols","propertyIsEnumerable"],"sources":["/Users/20016369/projet_ecole/mon-portfolio/node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js"],"sourcesContent":["/**\n* @vue/reactivity v3.5.13\n* (c) 2018-present Yuxi (Evan) You and Vue contributors\n* @license MIT\n**/\nimport { hasChanged, extend, isArray, isIntegerKey, isSymbol, isMap, hasOwn, isObject, makeMap, toRawType, capitalize, def, isFunction, EMPTY_OBJ, isSet, isPlainObject, NOOP, remove } from '@vue/shared';\n\nfunction warn(msg, ...args) {\n  console.warn(`[Vue warn] ${msg}`, ...args);\n}\n\nlet activeEffectScope;\nclass EffectScope {\n  constructor(detached = false) {\n    this.detached = detached;\n    /**\n     * @internal\n     */\n    this._active = true;\n    /**\n     * @internal\n     */\n    this.effects = [];\n    /**\n     * @internal\n     */\n    this.cleanups = [];\n    this._isPaused = false;\n    this.parent = activeEffectScope;\n    if (!detached && activeEffectScope) {\n      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(\n        this\n      ) - 1;\n    }\n  }\n  get active() {\n    return this._active;\n  }\n  pause() {\n    if (this._active) {\n      this._isPaused = true;\n      let i, l;\n      if (this.scopes) {\n        for (i = 0, l = this.scopes.length; i < l; i++) {\n          this.scopes[i].pause();\n        }\n      }\n      for (i = 0, l = this.effects.length; i < l; i++) {\n        this.effects[i].pause();\n      }\n    }\n  }\n  /**\n   * Resumes the effect scope, including all child scopes and effects.\n   */\n  resume() {\n    if (this._active) {\n      if (this._isPaused) {\n        this._isPaused = false;\n        let i, l;\n        if (this.scopes) {\n          for (i = 0, l = this.scopes.length; i < l; i++) {\n            this.scopes[i].resume();\n          }\n        }\n        for (i = 0, l = this.effects.length; i < l; i++) {\n          this.effects[i].resume();\n        }\n      }\n    }\n  }\n  run(fn) {\n    if (this._active) {\n      const currentEffectScope = activeEffectScope;\n      try {\n        activeEffectScope = this;\n        return fn();\n      } finally {\n        activeEffectScope = currentEffectScope;\n      }\n    } else if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(`cannot run an inactive effect scope.`);\n    }\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  on() {\n    activeEffectScope = this;\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  off() {\n    activeEffectScope = this.parent;\n  }\n  stop(fromParent) {\n    if (this._active) {\n      this._active = false;\n      let i, l;\n      for (i = 0, l = this.effects.length; i < l; i++) {\n        this.effects[i].stop();\n      }\n      this.effects.length = 0;\n      for (i = 0, l = this.cleanups.length; i < l; i++) {\n        this.cleanups[i]();\n      }\n      this.cleanups.length = 0;\n      if (this.scopes) {\n        for (i = 0, l = this.scopes.length; i < l; i++) {\n          this.scopes[i].stop(true);\n        }\n        this.scopes.length = 0;\n      }\n      if (!this.detached && this.parent && !fromParent) {\n        const last = this.parent.scopes.pop();\n        if (last && last !== this) {\n          this.parent.scopes[this.index] = last;\n          last.index = this.index;\n        }\n      }\n      this.parent = void 0;\n    }\n  }\n}\nfunction effectScope(detached) {\n  return new EffectScope(detached);\n}\nfunction getCurrentScope() {\n  return activeEffectScope;\n}\nfunction onScopeDispose(fn, failSilently = false) {\n  if (activeEffectScope) {\n    activeEffectScope.cleanups.push(fn);\n  } else if (!!(process.env.NODE_ENV !== \"production\") && !failSilently) {\n    warn(\n      `onScopeDispose() is called when there is no active effect scope to be associated with.`\n    );\n  }\n}\n\nlet activeSub;\nconst EffectFlags = {\n  \"ACTIVE\": 1,\n  \"1\": \"ACTIVE\",\n  \"RUNNING\": 2,\n  \"2\": \"RUNNING\",\n  \"TRACKING\": 4,\n  \"4\": \"TRACKING\",\n  \"NOTIFIED\": 8,\n  \"8\": \"NOTIFIED\",\n  \"DIRTY\": 16,\n  \"16\": \"DIRTY\",\n  \"ALLOW_RECURSE\": 32,\n  \"32\": \"ALLOW_RECURSE\",\n  \"PAUSED\": 64,\n  \"64\": \"PAUSED\"\n};\nconst pausedQueueEffects = /* @__PURE__ */ new WeakSet();\nclass ReactiveEffect {\n  constructor(fn) {\n    this.fn = fn;\n    /**\n     * @internal\n     */\n    this.deps = void 0;\n    /**\n     * @internal\n     */\n    this.depsTail = void 0;\n    /**\n     * @internal\n     */\n    this.flags = 1 | 4;\n    /**\n     * @internal\n     */\n    this.next = void 0;\n    /**\n     * @internal\n     */\n    this.cleanup = void 0;\n    this.scheduler = void 0;\n    if (activeEffectScope && activeEffectScope.active) {\n      activeEffectScope.effects.push(this);\n    }\n  }\n  pause() {\n    this.flags |= 64;\n  }\n  resume() {\n    if (this.flags & 64) {\n      this.flags &= ~64;\n      if (pausedQueueEffects.has(this)) {\n        pausedQueueEffects.delete(this);\n        this.trigger();\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  notify() {\n    if (this.flags & 2 && !(this.flags & 32)) {\n      return;\n    }\n    if (!(this.flags & 8)) {\n      batch(this);\n    }\n  }\n  run() {\n    if (!(this.flags & 1)) {\n      return this.fn();\n    }\n    this.flags |= 2;\n    cleanupEffect(this);\n    prepareDeps(this);\n    const prevEffect = activeSub;\n    const prevShouldTrack = shouldTrack;\n    activeSub = this;\n    shouldTrack = true;\n    try {\n      return this.fn();\n    } finally {\n      if (!!(process.env.NODE_ENV !== \"production\") && activeSub !== this) {\n        warn(\n          \"Active effect was not restored correctly - this is likely a Vue internal bug.\"\n        );\n      }\n      cleanupDeps(this);\n      activeSub = prevEffect;\n      shouldTrack = prevShouldTrack;\n      this.flags &= ~2;\n    }\n  }\n  stop() {\n    if (this.flags & 1) {\n      for (let link = this.deps; link; link = link.nextDep) {\n        removeSub(link);\n      }\n      this.deps = this.depsTail = void 0;\n      cleanupEffect(this);\n      this.onStop && this.onStop();\n      this.flags &= ~1;\n    }\n  }\n  trigger() {\n    if (this.flags & 64) {\n      pausedQueueEffects.add(this);\n    } else if (this.scheduler) {\n      this.scheduler();\n    } else {\n      this.runIfDirty();\n    }\n  }\n  /**\n   * @internal\n   */\n  runIfDirty() {\n    if (isDirty(this)) {\n      this.run();\n    }\n  }\n  get dirty() {\n    return isDirty(this);\n  }\n}\nlet batchDepth = 0;\nlet batchedSub;\nlet batchedComputed;\nfunction batch(sub, isComputed = false) {\n  sub.flags |= 8;\n  if (isComputed) {\n    sub.next = batchedComputed;\n    batchedComputed = sub;\n    return;\n  }\n  sub.next = batchedSub;\n  batchedSub = sub;\n}\nfunction startBatch() {\n  batchDepth++;\n}\nfunction endBatch() {\n  if (--batchDepth > 0) {\n    return;\n  }\n  if (batchedComputed) {\n    let e = batchedComputed;\n    batchedComputed = void 0;\n    while (e) {\n      const next = e.next;\n      e.next = void 0;\n      e.flags &= ~8;\n      e = next;\n    }\n  }\n  let error;\n  while (batchedSub) {\n    let e = batchedSub;\n    batchedSub = void 0;\n    while (e) {\n      const next = e.next;\n      e.next = void 0;\n      e.flags &= ~8;\n      if (e.flags & 1) {\n        try {\n          ;\n          e.trigger();\n        } catch (err) {\n          if (!error) error = err;\n        }\n      }\n      e = next;\n    }\n  }\n  if (error) throw error;\n}\nfunction prepareDeps(sub) {\n  for (let link = sub.deps; link; link = link.nextDep) {\n    link.version = -1;\n    link.prevActiveLink = link.dep.activeLink;\n    link.dep.activeLink = link;\n  }\n}\nfunction cleanupDeps(sub) {\n  let head;\n  let tail = sub.depsTail;\n  let link = tail;\n  while (link) {\n    const prev = link.prevDep;\n    if (link.version === -1) {\n      if (link === tail) tail = prev;\n      removeSub(link);\n      removeDep(link);\n    } else {\n      head = link;\n    }\n    link.dep.activeLink = link.prevActiveLink;\n    link.prevActiveLink = void 0;\n    link = prev;\n  }\n  sub.deps = head;\n  sub.depsTail = tail;\n}\nfunction isDirty(sub) {\n  for (let link = sub.deps; link; link = link.nextDep) {\n    if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {\n      return true;\n    }\n  }\n  if (sub._dirty) {\n    return true;\n  }\n  return false;\n}\nfunction refreshComputed(computed) {\n  if (computed.flags & 4 && !(computed.flags & 16)) {\n    return;\n  }\n  computed.flags &= ~16;\n  if (computed.globalVersion === globalVersion) {\n    return;\n  }\n  computed.globalVersion = globalVersion;\n  const dep = computed.dep;\n  computed.flags |= 2;\n  if (dep.version > 0 && !computed.isSSR && computed.deps && !isDirty(computed)) {\n    computed.flags &= ~2;\n    return;\n  }\n  const prevSub = activeSub;\n  const prevShouldTrack = shouldTrack;\n  activeSub = computed;\n  shouldTrack = true;\n  try {\n    prepareDeps(computed);\n    const value = computed.fn(computed._value);\n    if (dep.version === 0 || hasChanged(value, computed._value)) {\n      computed._value = value;\n      dep.version++;\n    }\n  } catch (err) {\n    dep.version++;\n    throw err;\n  } finally {\n    activeSub = prevSub;\n    shouldTrack = prevShouldTrack;\n    cleanupDeps(computed);\n    computed.flags &= ~2;\n  }\n}\nfunction removeSub(link, soft = false) {\n  const { dep, prevSub, nextSub } = link;\n  if (prevSub) {\n    prevSub.nextSub = nextSub;\n    link.prevSub = void 0;\n  }\n  if (nextSub) {\n    nextSub.prevSub = prevSub;\n    link.nextSub = void 0;\n  }\n  if (!!(process.env.NODE_ENV !== \"production\") && dep.subsHead === link) {\n    dep.subsHead = nextSub;\n  }\n  if (dep.subs === link) {\n    dep.subs = prevSub;\n    if (!prevSub && dep.computed) {\n      dep.computed.flags &= ~4;\n      for (let l = dep.computed.deps; l; l = l.nextDep) {\n        removeSub(l, true);\n      }\n    }\n  }\n  if (!soft && !--dep.sc && dep.map) {\n    dep.map.delete(dep.key);\n  }\n}\nfunction removeDep(link) {\n  const { prevDep, nextDep } = link;\n  if (prevDep) {\n    prevDep.nextDep = nextDep;\n    link.prevDep = void 0;\n  }\n  if (nextDep) {\n    nextDep.prevDep = prevDep;\n    link.nextDep = void 0;\n  }\n}\nfunction effect(fn, options) {\n  if (fn.effect instanceof ReactiveEffect) {\n    fn = fn.effect.fn;\n  }\n  const e = new ReactiveEffect(fn);\n  if (options) {\n    extend(e, options);\n  }\n  try {\n    e.run();\n  } catch (err) {\n    e.stop();\n    throw err;\n  }\n  const runner = e.run.bind(e);\n  runner.effect = e;\n  return runner;\n}\nfunction stop(runner) {\n  runner.effect.stop();\n}\nlet shouldTrack = true;\nconst trackStack = [];\nfunction pauseTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = false;\n}\nfunction enableTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = true;\n}\nfunction resetTracking() {\n  const last = trackStack.pop();\n  shouldTrack = last === void 0 ? true : last;\n}\nfunction onEffectCleanup(fn, failSilently = false) {\n  if (activeSub instanceof ReactiveEffect) {\n    activeSub.cleanup = fn;\n  } else if (!!(process.env.NODE_ENV !== \"production\") && !failSilently) {\n    warn(\n      `onEffectCleanup() was called when there was no active effect to associate with.`\n    );\n  }\n}\nfunction cleanupEffect(e) {\n  const { cleanup } = e;\n  e.cleanup = void 0;\n  if (cleanup) {\n    const prevSub = activeSub;\n    activeSub = void 0;\n    try {\n      cleanup();\n    } finally {\n      activeSub = prevSub;\n    }\n  }\n}\n\nlet globalVersion = 0;\nclass Link {\n  constructor(sub, dep) {\n    this.sub = sub;\n    this.dep = dep;\n    this.version = dep.version;\n    this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;\n  }\n}\nclass Dep {\n  constructor(computed) {\n    this.computed = computed;\n    this.version = 0;\n    /**\n     * Link between this dep and the current active effect\n     */\n    this.activeLink = void 0;\n    /**\n     * Doubly linked list representing the subscribing effects (tail)\n     */\n    this.subs = void 0;\n    /**\n     * For object property deps cleanup\n     */\n    this.map = void 0;\n    this.key = void 0;\n    /**\n     * Subscriber counter\n     */\n    this.sc = 0;\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      this.subsHead = void 0;\n    }\n  }\n  track(debugInfo) {\n    if (!activeSub || !shouldTrack || activeSub === this.computed) {\n      return;\n    }\n    let link = this.activeLink;\n    if (link === void 0 || link.sub !== activeSub) {\n      link = this.activeLink = new Link(activeSub, this);\n      if (!activeSub.deps) {\n        activeSub.deps = activeSub.depsTail = link;\n      } else {\n        link.prevDep = activeSub.depsTail;\n        activeSub.depsTail.nextDep = link;\n        activeSub.depsTail = link;\n      }\n      addSub(link);\n    } else if (link.version === -1) {\n      link.version = this.version;\n      if (link.nextDep) {\n        const next = link.nextDep;\n        next.prevDep = link.prevDep;\n        if (link.prevDep) {\n          link.prevDep.nextDep = next;\n        }\n        link.prevDep = activeSub.depsTail;\n        link.nextDep = void 0;\n        activeSub.depsTail.nextDep = link;\n        activeSub.depsTail = link;\n        if (activeSub.deps === link) {\n          activeSub.deps = next;\n        }\n      }\n    }\n    if (!!(process.env.NODE_ENV !== \"production\") && activeSub.onTrack) {\n      activeSub.onTrack(\n        extend(\n          {\n            effect: activeSub\n          },\n          debugInfo\n        )\n      );\n    }\n    return link;\n  }\n  trigger(debugInfo) {\n    this.version++;\n    globalVersion++;\n    this.notify(debugInfo);\n  }\n  notify(debugInfo) {\n    startBatch();\n    try {\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        for (let head = this.subsHead; head; head = head.nextSub) {\n          if (head.sub.onTrigger && !(head.sub.flags & 8)) {\n            head.sub.onTrigger(\n              extend(\n                {\n                  effect: head.sub\n                },\n                debugInfo\n              )\n            );\n          }\n        }\n      }\n      for (let link = this.subs; link; link = link.prevSub) {\n        if (link.sub.notify()) {\n          ;\n          link.sub.dep.notify();\n        }\n      }\n    } finally {\n      endBatch();\n    }\n  }\n}\nfunction addSub(link) {\n  link.dep.sc++;\n  if (link.sub.flags & 4) {\n    const computed = link.dep.computed;\n    if (computed && !link.dep.subs) {\n      computed.flags |= 4 | 16;\n      for (let l = computed.deps; l; l = l.nextDep) {\n        addSub(l);\n      }\n    }\n    const currentTail = link.dep.subs;\n    if (currentTail !== link) {\n      link.prevSub = currentTail;\n      if (currentTail) currentTail.nextSub = link;\n    }\n    if (!!(process.env.NODE_ENV !== \"production\") && link.dep.subsHead === void 0) {\n      link.dep.subsHead = link;\n    }\n    link.dep.subs = link;\n  }\n}\nconst targetMap = /* @__PURE__ */ new WeakMap();\nconst ITERATE_KEY = Symbol(\n  !!(process.env.NODE_ENV !== \"production\") ? \"Object iterate\" : \"\"\n);\nconst MAP_KEY_ITERATE_KEY = Symbol(\n  !!(process.env.NODE_ENV !== \"production\") ? \"Map keys iterate\" : \"\"\n);\nconst ARRAY_ITERATE_KEY = Symbol(\n  !!(process.env.NODE_ENV !== \"production\") ? \"Array iterate\" : \"\"\n);\nfunction track(target, type, key) {\n  if (shouldTrack && activeSub) {\n    let depsMap = targetMap.get(target);\n    if (!depsMap) {\n      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());\n    }\n    let dep = depsMap.get(key);\n    if (!dep) {\n      depsMap.set(key, dep = new Dep());\n      dep.map = depsMap;\n      dep.key = key;\n    }\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      dep.track({\n        target,\n        type,\n        key\n      });\n    } else {\n      dep.track();\n    }\n  }\n}\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\n  const depsMap = targetMap.get(target);\n  if (!depsMap) {\n    globalVersion++;\n    return;\n  }\n  const run = (dep) => {\n    if (dep) {\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        dep.trigger({\n          target,\n          type,\n          key,\n          newValue,\n          oldValue,\n          oldTarget\n        });\n      } else {\n        dep.trigger();\n      }\n    }\n  };\n  startBatch();\n  if (type === \"clear\") {\n    depsMap.forEach(run);\n  } else {\n    const targetIsArray = isArray(target);\n    const isArrayIndex = targetIsArray && isIntegerKey(key);\n    if (targetIsArray && key === \"length\") {\n      const newLength = Number(newValue);\n      depsMap.forEach((dep, key2) => {\n        if (key2 === \"length\" || key2 === ARRAY_ITERATE_KEY || !isSymbol(key2) && key2 >= newLength) {\n          run(dep);\n        }\n      });\n    } else {\n      if (key !== void 0 || depsMap.has(void 0)) {\n        run(depsMap.get(key));\n      }\n      if (isArrayIndex) {\n        run(depsMap.get(ARRAY_ITERATE_KEY));\n      }\n      switch (type) {\n        case \"add\":\n          if (!targetIsArray) {\n            run(depsMap.get(ITERATE_KEY));\n            if (isMap(target)) {\n              run(depsMap.get(MAP_KEY_ITERATE_KEY));\n            }\n          } else if (isArrayIndex) {\n            run(depsMap.get(\"length\"));\n          }\n          break;\n        case \"delete\":\n          if (!targetIsArray) {\n            run(depsMap.get(ITERATE_KEY));\n            if (isMap(target)) {\n              run(depsMap.get(MAP_KEY_ITERATE_KEY));\n            }\n          }\n          break;\n        case \"set\":\n          if (isMap(target)) {\n            run(depsMap.get(ITERATE_KEY));\n          }\n          break;\n      }\n    }\n  }\n  endBatch();\n}\nfunction getDepFromReactive(object, key) {\n  const depMap = targetMap.get(object);\n  return depMap && depMap.get(key);\n}\n\nfunction reactiveReadArray(array) {\n  const raw = toRaw(array);\n  if (raw === array) return raw;\n  track(raw, \"iterate\", ARRAY_ITERATE_KEY);\n  return isShallow(array) ? raw : raw.map(toReactive);\n}\nfunction shallowReadArray(arr) {\n  track(arr = toRaw(arr), \"iterate\", ARRAY_ITERATE_KEY);\n  return arr;\n}\nconst arrayInstrumentations = {\n  __proto__: null,\n  [Symbol.iterator]() {\n    return iterator(this, Symbol.iterator, toReactive);\n  },\n  concat(...args) {\n    return reactiveReadArray(this).concat(\n      ...args.map((x) => isArray(x) ? reactiveReadArray(x) : x)\n    );\n  },\n  entries() {\n    return iterator(this, \"entries\", (value) => {\n      value[1] = toReactive(value[1]);\n      return value;\n    });\n  },\n  every(fn, thisArg) {\n    return apply(this, \"every\", fn, thisArg, void 0, arguments);\n  },\n  filter(fn, thisArg) {\n    return apply(this, \"filter\", fn, thisArg, (v) => v.map(toReactive), arguments);\n  },\n  find(fn, thisArg) {\n    return apply(this, \"find\", fn, thisArg, toReactive, arguments);\n  },\n  findIndex(fn, thisArg) {\n    return apply(this, \"findIndex\", fn, thisArg, void 0, arguments);\n  },\n  findLast(fn, thisArg) {\n    return apply(this, \"findLast\", fn, thisArg, toReactive, arguments);\n  },\n  findLastIndex(fn, thisArg) {\n    return apply(this, \"findLastIndex\", fn, thisArg, void 0, arguments);\n  },\n  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement\n  forEach(fn, thisArg) {\n    return apply(this, \"forEach\", fn, thisArg, void 0, arguments);\n  },\n  includes(...args) {\n    return searchProxy(this, \"includes\", args);\n  },\n  indexOf(...args) {\n    return searchProxy(this, \"indexOf\", args);\n  },\n  join(separator) {\n    return reactiveReadArray(this).join(separator);\n  },\n  // keys() iterator only reads `length`, no optimisation required\n  lastIndexOf(...args) {\n    return searchProxy(this, \"lastIndexOf\", args);\n  },\n  map(fn, thisArg) {\n    return apply(this, \"map\", fn, thisArg, void 0, arguments);\n  },\n  pop() {\n    return noTracking(this, \"pop\");\n  },\n  push(...args) {\n    return noTracking(this, \"push\", args);\n  },\n  reduce(fn, ...args) {\n    return reduce(this, \"reduce\", fn, args);\n  },\n  reduceRight(fn, ...args) {\n    return reduce(this, \"reduceRight\", fn, args);\n  },\n  shift() {\n    return noTracking(this, \"shift\");\n  },\n  // slice could use ARRAY_ITERATE but also seems to beg for range tracking\n  some(fn, thisArg) {\n    return apply(this, \"some\", fn, thisArg, void 0, arguments);\n  },\n  splice(...args) {\n    return noTracking(this, \"splice\", args);\n  },\n  toReversed() {\n    return reactiveReadArray(this).toReversed();\n  },\n  toSorted(comparer) {\n    return reactiveReadArray(this).toSorted(comparer);\n  },\n  toSpliced(...args) {\n    return reactiveReadArray(this).toSpliced(...args);\n  },\n  unshift(...args) {\n    return noTracking(this, \"unshift\", args);\n  },\n  values() {\n    return iterator(this, \"values\", toReactive);\n  }\n};\nfunction iterator(self, method, wrapValue) {\n  const arr = shallowReadArray(self);\n  const iter = arr[method]();\n  if (arr !== self && !isShallow(self)) {\n    iter._next = iter.next;\n    iter.next = () => {\n      const result = iter._next();\n      if (result.value) {\n        result.value = wrapValue(result.value);\n      }\n      return result;\n    };\n  }\n  return iter;\n}\nconst arrayProto = Array.prototype;\nfunction apply(self, method, fn, thisArg, wrappedRetFn, args) {\n  const arr = shallowReadArray(self);\n  const needsWrap = arr !== self && !isShallow(self);\n  const methodFn = arr[method];\n  if (methodFn !== arrayProto[method]) {\n    const result2 = methodFn.apply(self, args);\n    return needsWrap ? toReactive(result2) : result2;\n  }\n  let wrappedFn = fn;\n  if (arr !== self) {\n    if (needsWrap) {\n      wrappedFn = function(item, index) {\n        return fn.call(this, toReactive(item), index, self);\n      };\n    } else if (fn.length > 2) {\n      wrappedFn = function(item, index) {\n        return fn.call(this, item, index, self);\n      };\n    }\n  }\n  const result = methodFn.call(arr, wrappedFn, thisArg);\n  return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;\n}\nfunction reduce(self, method, fn, args) {\n  const arr = shallowReadArray(self);\n  let wrappedFn = fn;\n  if (arr !== self) {\n    if (!isShallow(self)) {\n      wrappedFn = function(acc, item, index) {\n        return fn.call(this, acc, toReactive(item), index, self);\n      };\n    } else if (fn.length > 3) {\n      wrappedFn = function(acc, item, index) {\n        return fn.call(this, acc, item, index, self);\n      };\n    }\n  }\n  return arr[method](wrappedFn, ...args);\n}\nfunction searchProxy(self, method, args) {\n  const arr = toRaw(self);\n  track(arr, \"iterate\", ARRAY_ITERATE_KEY);\n  const res = arr[method](...args);\n  if ((res === -1 || res === false) && isProxy(args[0])) {\n    args[0] = toRaw(args[0]);\n    return arr[method](...args);\n  }\n  return res;\n}\nfunction noTracking(self, method, args = []) {\n  pauseTracking();\n  startBatch();\n  const res = toRaw(self)[method].apply(self, args);\n  endBatch();\n  resetTracking();\n  return res;\n}\n\nconst isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);\nconst builtInSymbols = new Set(\n  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== \"arguments\" && key !== \"caller\").map((key) => Symbol[key]).filter(isSymbol)\n);\nfunction hasOwnProperty(key) {\n  if (!isSymbol(key)) key = String(key);\n  const obj = toRaw(this);\n  track(obj, \"has\", key);\n  return obj.hasOwnProperty(key);\n}\nclass BaseReactiveHandler {\n  constructor(_isReadonly = false, _isShallow = false) {\n    this._isReadonly = _isReadonly;\n    this._isShallow = _isShallow;\n  }\n  get(target, key, receiver) {\n    if (key === \"__v_skip\") return target[\"__v_skip\"];\n    const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;\n    if (key === \"__v_isReactive\") {\n      return !isReadonly2;\n    } else if (key === \"__v_isReadonly\") {\n      return isReadonly2;\n    } else if (key === \"__v_isShallow\") {\n      return isShallow2;\n    } else if (key === \"__v_raw\") {\n      if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype\n      // this means the receiver is a user proxy of the reactive proxy\n      Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {\n        return target;\n      }\n      return;\n    }\n    const targetIsArray = isArray(target);\n    if (!isReadonly2) {\n      let fn;\n      if (targetIsArray && (fn = arrayInstrumentations[key])) {\n        return fn;\n      }\n      if (key === \"hasOwnProperty\") {\n        return hasOwnProperty;\n      }\n    }\n    const res = Reflect.get(\n      target,\n      key,\n      // if this is a proxy wrapping a ref, return methods using the raw ref\n      // as receiver so that we don't have to call `toRaw` on the ref in all\n      // its class methods\n      isRef(target) ? target : receiver\n    );\n    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n      return res;\n    }\n    if (!isReadonly2) {\n      track(target, \"get\", key);\n    }\n    if (isShallow2) {\n      return res;\n    }\n    if (isRef(res)) {\n      return targetIsArray && isIntegerKey(key) ? res : res.value;\n    }\n    if (isObject(res)) {\n      return isReadonly2 ? readonly(res) : reactive(res);\n    }\n    return res;\n  }\n}\nclass MutableReactiveHandler extends BaseReactiveHandler {\n  constructor(isShallow2 = false) {\n    super(false, isShallow2);\n  }\n  set(target, key, value, receiver) {\n    let oldValue = target[key];\n    if (!this._isShallow) {\n      const isOldValueReadonly = isReadonly(oldValue);\n      if (!isShallow(value) && !isReadonly(value)) {\n        oldValue = toRaw(oldValue);\n        value = toRaw(value);\n      }\n      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\n        if (isOldValueReadonly) {\n          return false;\n        } else {\n          oldValue.value = value;\n          return true;\n        }\n      }\n    }\n    const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);\n    const result = Reflect.set(\n      target,\n      key,\n      value,\n      isRef(target) ? target : receiver\n    );\n    if (target === toRaw(receiver)) {\n      if (!hadKey) {\n        trigger(target, \"add\", key, value);\n      } else if (hasChanged(value, oldValue)) {\n        trigger(target, \"set\", key, value, oldValue);\n      }\n    }\n    return result;\n  }\n  deleteProperty(target, key) {\n    const hadKey = hasOwn(target, key);\n    const oldValue = target[key];\n    const result = Reflect.deleteProperty(target, key);\n    if (result && hadKey) {\n      trigger(target, \"delete\", key, void 0, oldValue);\n    }\n    return result;\n  }\n  has(target, key) {\n    const result = Reflect.has(target, key);\n    if (!isSymbol(key) || !builtInSymbols.has(key)) {\n      track(target, \"has\", key);\n    }\n    return result;\n  }\n  ownKeys(target) {\n    track(\n      target,\n      \"iterate\",\n      isArray(target) ? \"length\" : ITERATE_KEY\n    );\n    return Reflect.ownKeys(target);\n  }\n}\nclass ReadonlyReactiveHandler extends BaseReactiveHandler {\n  constructor(isShallow2 = false) {\n    super(true, isShallow2);\n  }\n  set(target, key) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(\n        `Set operation on key \"${String(key)}\" failed: target is readonly.`,\n        target\n      );\n    }\n    return true;\n  }\n  deleteProperty(target, key) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(\n        `Delete operation on key \"${String(key)}\" failed: target is readonly.`,\n        target\n      );\n    }\n    return true;\n  }\n}\nconst mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();\nconst readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();\nconst shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);\nconst shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);\n\nconst toShallow = (value) => value;\nconst getProto = (v) => Reflect.getPrototypeOf(v);\nfunction createIterableMethod(method, isReadonly2, isShallow2) {\n  return function(...args) {\n    const target = this[\"__v_raw\"];\n    const rawTarget = toRaw(target);\n    const targetIsMap = isMap(rawTarget);\n    const isPair = method === \"entries\" || method === Symbol.iterator && targetIsMap;\n    const isKeyOnly = method === \"keys\" && targetIsMap;\n    const innerIterator = target[method](...args);\n    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;\n    !isReadonly2 && track(\n      rawTarget,\n      \"iterate\",\n      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY\n    );\n    return {\n      // iterator protocol\n      next() {\n        const { value, done } = innerIterator.next();\n        return done ? { value, done } : {\n          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n          done\n        };\n      },\n      // iterable protocol\n      [Symbol.iterator]() {\n        return this;\n      }\n    };\n  };\n}\nfunction createReadonlyMethod(type) {\n  return function(...args) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      const key = args[0] ? `on key \"${args[0]}\" ` : ``;\n      warn(\n        `${capitalize(type)} operation ${key}failed: target is readonly.`,\n        toRaw(this)\n      );\n    }\n    return type === \"delete\" ? false : type === \"clear\" ? void 0 : this;\n  };\n}\nfunction createInstrumentations(readonly, shallow) {\n  const instrumentations = {\n    get(key) {\n      const target = this[\"__v_raw\"];\n      const rawTarget = toRaw(target);\n      const rawKey = toRaw(key);\n      if (!readonly) {\n        if (hasChanged(key, rawKey)) {\n          track(rawTarget, \"get\", key);\n        }\n        track(rawTarget, \"get\", rawKey);\n      }\n      const { has } = getProto(rawTarget);\n      const wrap = shallow ? toShallow : readonly ? toReadonly : toReactive;\n      if (has.call(rawTarget, key)) {\n        return wrap(target.get(key));\n      } else if (has.call(rawTarget, rawKey)) {\n        return wrap(target.get(rawKey));\n      } else if (target !== rawTarget) {\n        target.get(key);\n      }\n    },\n    get size() {\n      const target = this[\"__v_raw\"];\n      !readonly && track(toRaw(target), \"iterate\", ITERATE_KEY);\n      return Reflect.get(target, \"size\", target);\n    },\n    has(key) {\n      const target = this[\"__v_raw\"];\n      const rawTarget = toRaw(target);\n      const rawKey = toRaw(key);\n      if (!readonly) {\n        if (hasChanged(key, rawKey)) {\n          track(rawTarget, \"has\", key);\n        }\n        track(rawTarget, \"has\", rawKey);\n      }\n      return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);\n    },\n    forEach(callback, thisArg) {\n      const observed = this;\n      const target = observed[\"__v_raw\"];\n      const rawTarget = toRaw(target);\n      const wrap = shallow ? toShallow : readonly ? toReadonly : toReactive;\n      !readonly && track(rawTarget, \"iterate\", ITERATE_KEY);\n      return target.forEach((value, key) => {\n        return callback.call(thisArg, wrap(value), wrap(key), observed);\n      });\n    }\n  };\n  extend(\n    instrumentations,\n    readonly ? {\n      add: createReadonlyMethod(\"add\"),\n      set: createReadonlyMethod(\"set\"),\n      delete: createReadonlyMethod(\"delete\"),\n      clear: createReadonlyMethod(\"clear\")\n    } : {\n      add(value) {\n        if (!shallow && !isShallow(value) && !isReadonly(value)) {\n          value = toRaw(value);\n        }\n        const target = toRaw(this);\n        const proto = getProto(target);\n        const hadKey = proto.has.call(target, value);\n        if (!hadKey) {\n          target.add(value);\n          trigger(target, \"add\", value, value);\n        }\n        return this;\n      },\n      set(key, value) {\n        if (!shallow && !isShallow(value) && !isReadonly(value)) {\n          value = toRaw(value);\n        }\n        const target = toRaw(this);\n        const { has, get } = getProto(target);\n        let hadKey = has.call(target, key);\n        if (!hadKey) {\n          key = toRaw(key);\n          hadKey = has.call(target, key);\n        } else if (!!(process.env.NODE_ENV !== \"production\")) {\n          checkIdentityKeys(target, has, key);\n        }\n        const oldValue = get.call(target, key);\n        target.set(key, value);\n        if (!hadKey) {\n          trigger(target, \"add\", key, value);\n        } else if (hasChanged(value, oldValue)) {\n          trigger(target, \"set\", key, value, oldValue);\n        }\n        return this;\n      },\n      delete(key) {\n        const target = toRaw(this);\n        const { has, get } = getProto(target);\n        let hadKey = has.call(target, key);\n        if (!hadKey) {\n          key = toRaw(key);\n          hadKey = has.call(target, key);\n        } else if (!!(process.env.NODE_ENV !== \"production\")) {\n          checkIdentityKeys(target, has, key);\n        }\n        const oldValue = get ? get.call(target, key) : void 0;\n        const result = target.delete(key);\n        if (hadKey) {\n          trigger(target, \"delete\", key, void 0, oldValue);\n        }\n        return result;\n      },\n      clear() {\n        const target = toRaw(this);\n        const hadItems = target.size !== 0;\n        const oldTarget = !!(process.env.NODE_ENV !== \"production\") ? isMap(target) ? new Map(target) : new Set(target) : void 0;\n        const result = target.clear();\n        if (hadItems) {\n          trigger(\n            target,\n            \"clear\",\n            void 0,\n            void 0,\n            oldTarget\n          );\n        }\n        return result;\n      }\n    }\n  );\n  const iteratorMethods = [\n    \"keys\",\n    \"values\",\n    \"entries\",\n    Symbol.iterator\n  ];\n  iteratorMethods.forEach((method) => {\n    instrumentations[method] = createIterableMethod(method, readonly, shallow);\n  });\n  return instrumentations;\n}\nfunction createInstrumentationGetter(isReadonly2, shallow) {\n  const instrumentations = createInstrumentations(isReadonly2, shallow);\n  return (target, key, receiver) => {\n    if (key === \"__v_isReactive\") {\n      return !isReadonly2;\n    } else if (key === \"__v_isReadonly\") {\n      return isReadonly2;\n    } else if (key === \"__v_raw\") {\n      return target;\n    }\n    return Reflect.get(\n      hasOwn(instrumentations, key) && key in target ? instrumentations : target,\n      key,\n      receiver\n    );\n  };\n}\nconst mutableCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(false, false)\n};\nconst shallowCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(false, true)\n};\nconst readonlyCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(true, false)\n};\nconst shallowReadonlyCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(true, true)\n};\nfunction checkIdentityKeys(target, has, key) {\n  const rawKey = toRaw(key);\n  if (rawKey !== key && has.call(target, rawKey)) {\n    const type = toRawType(target);\n    warn(\n      `Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`\n    );\n  }\n}\n\nconst reactiveMap = /* @__PURE__ */ new WeakMap();\nconst shallowReactiveMap = /* @__PURE__ */ new WeakMap();\nconst readonlyMap = /* @__PURE__ */ new WeakMap();\nconst shallowReadonlyMap = /* @__PURE__ */ new WeakMap();\nfunction targetTypeMap(rawType) {\n  switch (rawType) {\n    case \"Object\":\n    case \"Array\":\n      return 1 /* COMMON */;\n    case \"Map\":\n    case \"Set\":\n    case \"WeakMap\":\n    case \"WeakSet\":\n      return 2 /* COLLECTION */;\n    default:\n      return 0 /* INVALID */;\n  }\n}\nfunction getTargetType(value) {\n  return value[\"__v_skip\"] || !Object.isExtensible(value) ? 0 /* INVALID */ : targetTypeMap(toRawType(value));\n}\nfunction reactive(target) {\n  if (isReadonly(target)) {\n    return target;\n  }\n  return createReactiveObject(\n    target,\n    false,\n    mutableHandlers,\n    mutableCollectionHandlers,\n    reactiveMap\n  );\n}\nfunction shallowReactive(target) {\n  return createReactiveObject(\n    target,\n    false,\n    shallowReactiveHandlers,\n    shallowCollectionHandlers,\n    shallowReactiveMap\n  );\n}\nfunction readonly(target) {\n  return createReactiveObject(\n    target,\n    true,\n    readonlyHandlers,\n    readonlyCollectionHandlers,\n    readonlyMap\n  );\n}\nfunction shallowReadonly(target) {\n  return createReactiveObject(\n    target,\n    true,\n    shallowReadonlyHandlers,\n    shallowReadonlyCollectionHandlers,\n    shallowReadonlyMap\n  );\n}\nfunction createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {\n  if (!isObject(target)) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(\n        `value cannot be made ${isReadonly2 ? \"readonly\" : \"reactive\"}: ${String(\n          target\n        )}`\n      );\n    }\n    return target;\n  }\n  if (target[\"__v_raw\"] && !(isReadonly2 && target[\"__v_isReactive\"])) {\n    return target;\n  }\n  const existingProxy = proxyMap.get(target);\n  if (existingProxy) {\n    return existingProxy;\n  }\n  const targetType = getTargetType(target);\n  if (targetType === 0 /* INVALID */) {\n    return target;\n  }\n  const proxy = new Proxy(\n    target,\n    targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers\n  );\n  proxyMap.set(target, proxy);\n  return proxy;\n}\nfunction isReactive(value) {\n  if (isReadonly(value)) {\n    return isReactive(value[\"__v_raw\"]);\n  }\n  return !!(value && value[\"__v_isReactive\"]);\n}\nfunction isReadonly(value) {\n  return !!(value && value[\"__v_isReadonly\"]);\n}\nfunction isShallow(value) {\n  return !!(value && value[\"__v_isShallow\"]);\n}\nfunction isProxy(value) {\n  return value ? !!value[\"__v_raw\"] : false;\n}\nfunction toRaw(observed) {\n  const raw = observed && observed[\"__v_raw\"];\n  return raw ? toRaw(raw) : observed;\n}\nfunction markRaw(value) {\n  if (!hasOwn(value, \"__v_skip\") && Object.isExtensible(value)) {\n    def(value, \"__v_skip\", true);\n  }\n  return value;\n}\nconst toReactive = (value) => isObject(value) ? reactive(value) : value;\nconst toReadonly = (value) => isObject(value) ? readonly(value) : value;\n\nfunction isRef(r) {\n  return r ? r[\"__v_isRef\"] === true : false;\n}\nfunction ref(value) {\n  return createRef(value, false);\n}\nfunction shallowRef(value) {\n  return createRef(value, true);\n}\nfunction createRef(rawValue, shallow) {\n  if (isRef(rawValue)) {\n    return rawValue;\n  }\n  return new RefImpl(rawValue, shallow);\n}\nclass RefImpl {\n  constructor(value, isShallow2) {\n    this.dep = new Dep();\n    this[\"__v_isRef\"] = true;\n    this[\"__v_isShallow\"] = false;\n    this._rawValue = isShallow2 ? value : toRaw(value);\n    this._value = isShallow2 ? value : toReactive(value);\n    this[\"__v_isShallow\"] = isShallow2;\n  }\n  get value() {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      this.dep.track({\n        target: this,\n        type: \"get\",\n        key: \"value\"\n      });\n    } else {\n      this.dep.track();\n    }\n    return this._value;\n  }\n  set value(newValue) {\n    const oldValue = this._rawValue;\n    const useDirectValue = this[\"__v_isShallow\"] || isShallow(newValue) || isReadonly(newValue);\n    newValue = useDirectValue ? newValue : toRaw(newValue);\n    if (hasChanged(newValue, oldValue)) {\n      this._rawValue = newValue;\n      this._value = useDirectValue ? newValue : toReactive(newValue);\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        this.dep.trigger({\n          target: this,\n          type: \"set\",\n          key: \"value\",\n          newValue,\n          oldValue\n        });\n      } else {\n        this.dep.trigger();\n      }\n    }\n  }\n}\nfunction triggerRef(ref2) {\n  if (ref2.dep) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      ref2.dep.trigger({\n        target: ref2,\n        type: \"set\",\n        key: \"value\",\n        newValue: ref2._value\n      });\n    } else {\n      ref2.dep.trigger();\n    }\n  }\n}\nfunction unref(ref2) {\n  return isRef(ref2) ? ref2.value : ref2;\n}\nfunction toValue(source) {\n  return isFunction(source) ? source() : unref(source);\n}\nconst shallowUnwrapHandlers = {\n  get: (target, key, receiver) => key === \"__v_raw\" ? target : unref(Reflect.get(target, key, receiver)),\n  set: (target, key, value, receiver) => {\n    const oldValue = target[key];\n    if (isRef(oldValue) && !isRef(value)) {\n      oldValue.value = value;\n      return true;\n    } else {\n      return Reflect.set(target, key, value, receiver);\n    }\n  }\n};\nfunction proxyRefs(objectWithRefs) {\n  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);\n}\nclass CustomRefImpl {\n  constructor(factory) {\n    this[\"__v_isRef\"] = true;\n    this._value = void 0;\n    const dep = this.dep = new Dep();\n    const { get, set } = factory(dep.track.bind(dep), dep.trigger.bind(dep));\n    this._get = get;\n    this._set = set;\n  }\n  get value() {\n    return this._value = this._get();\n  }\n  set value(newVal) {\n    this._set(newVal);\n  }\n}\nfunction customRef(factory) {\n  return new CustomRefImpl(factory);\n}\nfunction toRefs(object) {\n  if (!!(process.env.NODE_ENV !== \"production\") && !isProxy(object)) {\n    warn(`toRefs() expects a reactive object but received a plain one.`);\n  }\n  const ret = isArray(object) ? new Array(object.length) : {};\n  for (const key in object) {\n    ret[key] = propertyToRef(object, key);\n  }\n  return ret;\n}\nclass ObjectRefImpl {\n  constructor(_object, _key, _defaultValue) {\n    this._object = _object;\n    this._key = _key;\n    this._defaultValue = _defaultValue;\n    this[\"__v_isRef\"] = true;\n    this._value = void 0;\n  }\n  get value() {\n    const val = this._object[this._key];\n    return this._value = val === void 0 ? this._defaultValue : val;\n  }\n  set value(newVal) {\n    this._object[this._key] = newVal;\n  }\n  get dep() {\n    return getDepFromReactive(toRaw(this._object), this._key);\n  }\n}\nclass GetterRefImpl {\n  constructor(_getter) {\n    this._getter = _getter;\n    this[\"__v_isRef\"] = true;\n    this[\"__v_isReadonly\"] = true;\n    this._value = void 0;\n  }\n  get value() {\n    return this._value = this._getter();\n  }\n}\nfunction toRef(source, key, defaultValue) {\n  if (isRef(source)) {\n    return source;\n  } else if (isFunction(source)) {\n    return new GetterRefImpl(source);\n  } else if (isObject(source) && arguments.length > 1) {\n    return propertyToRef(source, key, defaultValue);\n  } else {\n    return ref(source);\n  }\n}\nfunction propertyToRef(source, key, defaultValue) {\n  const val = source[key];\n  return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);\n}\n\nclass ComputedRefImpl {\n  constructor(fn, setter, isSSR) {\n    this.fn = fn;\n    this.setter = setter;\n    /**\n     * @internal\n     */\n    this._value = void 0;\n    /**\n     * @internal\n     */\n    this.dep = new Dep(this);\n    /**\n     * @internal\n     */\n    this.__v_isRef = true;\n    // TODO isolatedDeclarations \"__v_isReadonly\"\n    // A computed is also a subscriber that tracks other deps\n    /**\n     * @internal\n     */\n    this.deps = void 0;\n    /**\n     * @internal\n     */\n    this.depsTail = void 0;\n    /**\n     * @internal\n     */\n    this.flags = 16;\n    /**\n     * @internal\n     */\n    this.globalVersion = globalVersion - 1;\n    /**\n     * @internal\n     */\n    this.next = void 0;\n    // for backwards compat\n    this.effect = this;\n    this[\"__v_isReadonly\"] = !setter;\n    this.isSSR = isSSR;\n  }\n  /**\n   * @internal\n   */\n  notify() {\n    this.flags |= 16;\n    if (!(this.flags & 8) && // avoid infinite self recursion\n    activeSub !== this) {\n      batch(this, true);\n      return true;\n    } else if (!!(process.env.NODE_ENV !== \"production\")) ;\n  }\n  get value() {\n    const link = !!(process.env.NODE_ENV !== \"production\") ? this.dep.track({\n      target: this,\n      type: \"get\",\n      key: \"value\"\n    }) : this.dep.track();\n    refreshComputed(this);\n    if (link) {\n      link.version = this.dep.version;\n    }\n    return this._value;\n  }\n  set value(newValue) {\n    if (this.setter) {\n      this.setter(newValue);\n    } else if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(\"Write operation failed: computed value is readonly\");\n    }\n  }\n}\nfunction computed(getterOrOptions, debugOptions, isSSR = false) {\n  let getter;\n  let setter;\n  if (isFunction(getterOrOptions)) {\n    getter = getterOrOptions;\n  } else {\n    getter = getterOrOptions.get;\n    setter = getterOrOptions.set;\n  }\n  const cRef = new ComputedRefImpl(getter, setter, isSSR);\n  if (!!(process.env.NODE_ENV !== \"production\") && debugOptions && !isSSR) {\n    cRef.onTrack = debugOptions.onTrack;\n    cRef.onTrigger = debugOptions.onTrigger;\n  }\n  return cRef;\n}\n\nconst TrackOpTypes = {\n  \"GET\": \"get\",\n  \"HAS\": \"has\",\n  \"ITERATE\": \"iterate\"\n};\nconst TriggerOpTypes = {\n  \"SET\": \"set\",\n  \"ADD\": \"add\",\n  \"DELETE\": \"delete\",\n  \"CLEAR\": \"clear\"\n};\nconst ReactiveFlags = {\n  \"SKIP\": \"__v_skip\",\n  \"IS_REACTIVE\": \"__v_isReactive\",\n  \"IS_READONLY\": \"__v_isReadonly\",\n  \"IS_SHALLOW\": \"__v_isShallow\",\n  \"RAW\": \"__v_raw\",\n  \"IS_REF\": \"__v_isRef\"\n};\n\nconst WatchErrorCodes = {\n  \"WATCH_GETTER\": 2,\n  \"2\": \"WATCH_GETTER\",\n  \"WATCH_CALLBACK\": 3,\n  \"3\": \"WATCH_CALLBACK\",\n  \"WATCH_CLEANUP\": 4,\n  \"4\": \"WATCH_CLEANUP\"\n};\nconst INITIAL_WATCHER_VALUE = {};\nconst cleanupMap = /* @__PURE__ */ new WeakMap();\nlet activeWatcher = void 0;\nfunction getCurrentWatcher() {\n  return activeWatcher;\n}\nfunction onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {\n  if (owner) {\n    let cleanups = cleanupMap.get(owner);\n    if (!cleanups) cleanupMap.set(owner, cleanups = []);\n    cleanups.push(cleanupFn);\n  } else if (!!(process.env.NODE_ENV !== \"production\") && !failSilently) {\n    warn(\n      `onWatcherCleanup() was called when there was no active watcher to associate with.`\n    );\n  }\n}\nfunction watch(source, cb, options = EMPTY_OBJ) {\n  const { immediate, deep, once, scheduler, augmentJob, call } = options;\n  const warnInvalidSource = (s) => {\n    (options.onWarn || warn)(\n      `Invalid watch source: `,\n      s,\n      `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`\n    );\n  };\n  const reactiveGetter = (source2) => {\n    if (deep) return source2;\n    if (isShallow(source2) || deep === false || deep === 0)\n      return traverse(source2, 1);\n    return traverse(source2);\n  };\n  let effect;\n  let getter;\n  let cleanup;\n  let boundCleanup;\n  let forceTrigger = false;\n  let isMultiSource = false;\n  if (isRef(source)) {\n    getter = () => source.value;\n    forceTrigger = isShallow(source);\n  } else if (isReactive(source)) {\n    getter = () => reactiveGetter(source);\n    forceTrigger = true;\n  } else if (isArray(source)) {\n    isMultiSource = true;\n    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));\n    getter = () => source.map((s) => {\n      if (isRef(s)) {\n        return s.value;\n      } else if (isReactive(s)) {\n        return reactiveGetter(s);\n      } else if (isFunction(s)) {\n        return call ? call(s, 2) : s();\n      } else {\n        !!(process.env.NODE_ENV !== \"production\") && warnInvalidSource(s);\n      }\n    });\n  } else if (isFunction(source)) {\n    if (cb) {\n      getter = call ? () => call(source, 2) : source;\n    } else {\n      getter = () => {\n        if (cleanup) {\n          pauseTracking();\n          try {\n            cleanup();\n          } finally {\n            resetTracking();\n          }\n        }\n        const currentEffect = activeWatcher;\n        activeWatcher = effect;\n        try {\n          return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);\n        } finally {\n          activeWatcher = currentEffect;\n        }\n      };\n    }\n  } else {\n    getter = NOOP;\n    !!(process.env.NODE_ENV !== \"production\") && warnInvalidSource(source);\n  }\n  if (cb && deep) {\n    const baseGetter = getter;\n    const depth = deep === true ? Infinity : deep;\n    getter = () => traverse(baseGetter(), depth);\n  }\n  const scope = getCurrentScope();\n  const watchHandle = () => {\n    effect.stop();\n    if (scope && scope.active) {\n      remove(scope.effects, effect);\n    }\n  };\n  if (once && cb) {\n    const _cb = cb;\n    cb = (...args) => {\n      _cb(...args);\n      watchHandle();\n    };\n  }\n  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;\n  const job = (immediateFirstRun) => {\n    if (!(effect.flags & 1) || !effect.dirty && !immediateFirstRun) {\n      return;\n    }\n    if (cb) {\n      const newValue = effect.run();\n      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue))) {\n        if (cleanup) {\n          cleanup();\n        }\n        const currentWatcher = activeWatcher;\n        activeWatcher = effect;\n        try {\n          const args = [\n            newValue,\n            // pass undefined as the old value when it's changed for the first time\n            oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,\n            boundCleanup\n          ];\n          call ? call(cb, 3, args) : (\n            // @ts-expect-error\n            cb(...args)\n          );\n          oldValue = newValue;\n        } finally {\n          activeWatcher = currentWatcher;\n        }\n      }\n    } else {\n      effect.run();\n    }\n  };\n  if (augmentJob) {\n    augmentJob(job);\n  }\n  effect = new ReactiveEffect(getter);\n  effect.scheduler = scheduler ? () => scheduler(job, false) : job;\n  boundCleanup = (fn) => onWatcherCleanup(fn, false, effect);\n  cleanup = effect.onStop = () => {\n    const cleanups = cleanupMap.get(effect);\n    if (cleanups) {\n      if (call) {\n        call(cleanups, 4);\n      } else {\n        for (const cleanup2 of cleanups) cleanup2();\n      }\n      cleanupMap.delete(effect);\n    }\n  };\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    effect.onTrack = options.onTrack;\n    effect.onTrigger = options.onTrigger;\n  }\n  if (cb) {\n    if (immediate) {\n      job(true);\n    } else {\n      oldValue = effect.run();\n    }\n  } else if (scheduler) {\n    scheduler(job.bind(null, true), true);\n  } else {\n    effect.run();\n  }\n  watchHandle.pause = effect.pause.bind(effect);\n  watchHandle.resume = effect.resume.bind(effect);\n  watchHandle.stop = watchHandle;\n  return watchHandle;\n}\nfunction traverse(value, depth = Infinity, seen) {\n  if (depth <= 0 || !isObject(value) || value[\"__v_skip\"]) {\n    return value;\n  }\n  seen = seen || /* @__PURE__ */ new Set();\n  if (seen.has(value)) {\n    return value;\n  }\n  seen.add(value);\n  depth--;\n  if (isRef(value)) {\n    traverse(value.value, depth, seen);\n  } else if (isArray(value)) {\n    for (let i = 0; i < value.length; i++) {\n      traverse(value[i], depth, seen);\n    }\n  } else if (isSet(value) || isMap(value)) {\n    value.forEach((v) => {\n      traverse(v, depth, seen);\n    });\n  } else if (isPlainObject(value)) {\n    for (const key in value) {\n      traverse(value[key], depth, seen);\n    }\n    for (const key of Object.getOwnPropertySymbols(value)) {\n      if (Object.prototype.propertyIsEnumerable.call(value, key)) {\n        traverse(value[key], depth, seen);\n      }\n    }\n  }\n  return value;\n}\n\nexport { ARRAY_ITERATE_KEY, EffectFlags, EffectScope, ITERATE_KEY, MAP_KEY_ITERATE_KEY, ReactiveEffect, ReactiveFlags, TrackOpTypes, TriggerOpTypes, WatchErrorCodes, computed, customRef, effect, effectScope, enableTracking, getCurrentScope, getCurrentWatcher, isProxy, isReactive, isReadonly, isRef, isShallow, markRaw, onEffectCleanup, onScopeDispose, onWatcherCleanup, pauseTracking, proxyRefs, reactive, reactiveReadArray, readonly, ref, resetTracking, shallowReactive, shallowReadArray, shallowReadonly, shallowRef, stop, toRaw, toReactive, toReadonly, toRef, toRefs, toValue, track, traverse, trigger, triggerRef, unref, watch };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}