{"ast":null,"code":"/* eslint-disable sonarjs/no-identical-functions */\n// Utilities\nimport { toRaw } from 'vue';\nexport const independentSelectStrategy = mandatory => {\n  const strategy = {\n    select: _ref => {\n      let {\n        id,\n        value,\n        selected\n      } = _ref;\n      id = toRaw(id); // When mandatory and we're trying to deselect when id\n      // is the only currently selected item then do nothing\n\n      if (mandatory && !value) {\n        const on = Array.from(selected.entries()).reduce((arr, _ref2) => {\n          let [key, value] = _ref2;\n          if (value === 'on') arr.push(key);\n          return arr;\n        }, []);\n        if (on.length === 1 && on[0] === id) return selected;\n      }\n\n      selected.set(id, value ? 'on' : 'off');\n      return selected;\n    },\n    in: (v, children, parents) => {\n      const map = new Map();\n\n      for (const id of v || []) {\n        strategy.select({\n          id,\n          value: true,\n          selected: map,\n          children,\n          parents\n        });\n      }\n\n      return map;\n    },\n    out: v => {\n      const arr = [];\n\n      for (const [key, value] of v.entries()) {\n        if (value === 'on') arr.push(key);\n      }\n\n      return arr;\n    }\n  };\n  return strategy;\n};\nexport const independentSingleSelectStrategy = mandatory => {\n  const parentStrategy = independentSelectStrategy(mandatory);\n  const strategy = {\n    select: _ref3 => {\n      let {\n        selected,\n        id,\n        ...rest\n      } = _ref3;\n      id = toRaw(id);\n      const singleSelected = selected.has(id) ? new Map([[id, selected.get(id)]]) : new Map();\n      return parentStrategy.select({ ...rest,\n        id,\n        selected: singleSelected\n      });\n    },\n    in: (v, children, parents) => {\n      if (v?.length) {\n        return parentStrategy.in(v.slice(0, 1), children, parents);\n      }\n\n      return new Map();\n    },\n    out: (v, children, parents) => {\n      return parentStrategy.out(v, children, parents);\n    }\n  };\n  return strategy;\n};\nexport const leafSelectStrategy = mandatory => {\n  const parentStrategy = independentSelectStrategy(mandatory);\n  const strategy = {\n    select: _ref4 => {\n      let {\n        id,\n        selected,\n        children,\n        ...rest\n      } = _ref4;\n      id = toRaw(id);\n      if (children.has(id)) return selected;\n      return parentStrategy.select({\n        id,\n        selected,\n        children,\n        ...rest\n      });\n    },\n    in: parentStrategy.in,\n    out: parentStrategy.out\n  };\n  return strategy;\n};\nexport const leafSingleSelectStrategy = mandatory => {\n  const parentStrategy = independentSingleSelectStrategy(mandatory);\n  const strategy = {\n    select: _ref5 => {\n      let {\n        id,\n        selected,\n        children,\n        ...rest\n      } = _ref5;\n      id = toRaw(id);\n      if (children.has(id)) return selected;\n      return parentStrategy.select({\n        id,\n        selected,\n        children,\n        ...rest\n      });\n    },\n    in: parentStrategy.in,\n    out: parentStrategy.out\n  };\n  return strategy;\n};\nexport const classicSelectStrategy = mandatory => {\n  const strategy = {\n    select: _ref6 => {\n      let {\n        id,\n        value,\n        selected,\n        children,\n        parents\n      } = _ref6;\n      id = toRaw(id);\n      const original = new Map(selected);\n      const items = [id];\n\n      while (items.length) {\n        const item = items.shift();\n        selected.set(toRaw(item), value ? 'on' : 'off');\n\n        if (children.has(item)) {\n          items.push(...children.get(item));\n        }\n      }\n\n      let parent = toRaw(parents.get(id));\n\n      while (parent) {\n        const childrenIds = children.get(parent);\n        const everySelected = childrenIds.every(cid => selected.get(toRaw(cid)) === 'on');\n        const noneSelected = childrenIds.every(cid => !selected.has(toRaw(cid)) || selected.get(toRaw(cid)) === 'off');\n        selected.set(parent, everySelected ? 'on' : noneSelected ? 'off' : 'indeterminate');\n        parent = toRaw(parents.get(parent));\n      } // If mandatory and planned deselect results in no selected\n      // items then we can't do it, so return original state\n\n\n      if (mandatory && !value) {\n        const on = Array.from(selected.entries()).reduce((arr, _ref7) => {\n          let [key, value] = _ref7;\n          if (value === 'on') arr.push(key);\n          return arr;\n        }, []);\n        if (on.length === 0) return original;\n      }\n\n      return selected;\n    },\n    in: (v, children, parents) => {\n      let map = new Map();\n\n      for (const id of v || []) {\n        map = strategy.select({\n          id,\n          value: true,\n          selected: map,\n          children,\n          parents\n        });\n      }\n\n      return map;\n    },\n    out: (v, children) => {\n      const arr = [];\n\n      for (const [key, value] of v.entries()) {\n        if (value === 'on' && !children.has(key)) arr.push(key);\n      }\n\n      return arr;\n    }\n  };\n  return strategy;\n};","map":{"version":3,"mappings":"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","names":["toRaw","independentSelectStrategy","mandatory","strategy","select","_ref","id","value","selected","on","Array","from","entries","reduce","arr","_ref2","key","push","length","set","in","v","children","parents","map","Map","out","independentSingleSelectStrategy","parentStrategy","_ref3","rest","singleSelected","has","get","slice","leafSelectStrategy","_ref4","leafSingleSelectStrategy","_ref5","classicSelectStrategy","_ref6","original","items","item","shift","parent","childrenIds","everySelected","every","cid","noneSelected","_ref7"],"sources":["../../../src/composables/nested/selectStrategies.ts"],"sourcesContent":["/* eslint-disable sonarjs/no-identical-functions */\n// Utilities\nimport { toRaw } from 'vue'\n\nexport type SelectStrategyFn = (data: {\n  id: unknown\n  value: boolean\n  selected: Map<unknown, 'on' | 'off' | 'indeterminate'>\n  children: Map<unknown, unknown[]>\n  parents: Map<unknown, unknown>\n  event?: Event\n}) => Map<unknown, 'on' | 'off' | 'indeterminate'>\n\nexport type SelectStrategyTransformInFn = (\n  v: readonly unknown[] | undefined,\n  children: Map<unknown, unknown[]>,\n  parents: Map<unknown, unknown>,\n) => Map<unknown, 'on' | 'off' | 'indeterminate'>\n\nexport type SelectStrategyTransformOutFn = (\n  v: Map<unknown, 'on' | 'off' | 'indeterminate'>,\n  children: Map<unknown, unknown[]>,\n  parents: Map<unknown, unknown>,\n) => unknown[]\n\nexport type SelectStrategy = {\n  select: SelectStrategyFn\n  in: SelectStrategyTransformInFn\n  out: SelectStrategyTransformOutFn\n}\n\nexport const independentSelectStrategy = (mandatory?: boolean): SelectStrategy => {\n  const strategy: SelectStrategy = {\n    select: ({ id, value, selected }) => {\n      id = toRaw(id)\n\n      // When mandatory and we're trying to deselect when id\n      // is the only currently selected item then do nothing\n      if (mandatory && !value) {\n        const on = Array.from(selected.entries())\n          .reduce((arr, [key, value]) => {\n            if (value === 'on') arr.push(key)\n            return arr\n          }, [] as unknown[])\n        if (on.length === 1 && on[0] === id) return selected\n      }\n\n      selected.set(id, value ? 'on' : 'off')\n\n      return selected\n    },\n    in: (v, children, parents) => {\n      const map = new Map()\n\n      for (const id of (v || [])) {\n        strategy.select({\n          id,\n          value: true,\n          selected: map,\n          children,\n          parents,\n        })\n      }\n\n      return map\n    },\n    out: v => {\n      const arr = []\n\n      for (const [key, value] of v.entries()) {\n        if (value === 'on') arr.push(key)\n      }\n\n      return arr\n    },\n  }\n\n  return strategy\n}\n\nexport const independentSingleSelectStrategy = (mandatory?: boolean): SelectStrategy => {\n  const parentStrategy = independentSelectStrategy(mandatory)\n\n  const strategy: SelectStrategy = {\n    select: ({ selected, id, ...rest }) => {\n      id = toRaw(id)\n      const singleSelected = selected.has(id) ? new Map([[id, selected.get(id)!]]) : new Map()\n      return parentStrategy.select({ ...rest, id, selected: singleSelected })\n    },\n    in: (v, children, parents) => {\n      if (v?.length) {\n        return parentStrategy.in(v.slice(0, 1), children, parents)\n      }\n\n      return new Map()\n    },\n    out: (v, children, parents) => {\n      return parentStrategy.out(v, children, parents)\n    },\n  }\n\n  return strategy\n}\n\nexport const leafSelectStrategy = (mandatory?: boolean): SelectStrategy => {\n  const parentStrategy = independentSelectStrategy(mandatory)\n\n  const strategy: SelectStrategy = {\n    select: ({ id, selected, children, ...rest }) => {\n      id = toRaw(id)\n      if (children.has(id)) return selected\n\n      return parentStrategy.select({ id, selected, children, ...rest })\n    },\n    in: parentStrategy.in,\n    out: parentStrategy.out,\n  }\n\n  return strategy\n}\n\nexport const leafSingleSelectStrategy = (mandatory?: boolean): SelectStrategy => {\n  const parentStrategy = independentSingleSelectStrategy(mandatory)\n\n  const strategy: SelectStrategy = {\n    select: ({ id, selected, children, ...rest }) => {\n      id = toRaw(id)\n      if (children.has(id)) return selected\n\n      return parentStrategy.select({ id, selected, children, ...rest })\n    },\n    in: parentStrategy.in,\n    out: parentStrategy.out,\n  }\n\n  return strategy\n}\n\nexport const classicSelectStrategy = (mandatory?: boolean): SelectStrategy => {\n  const strategy: SelectStrategy = {\n    select: ({ id, value, selected, children, parents }) => {\n      id = toRaw(id)\n      const original = new Map(selected)\n\n      const items = [id]\n\n      while (items.length) {\n        const item = items.shift()!\n\n        selected.set(toRaw(item), value ? 'on' : 'off')\n\n        if (children.has(item)) {\n          items.push(...children.get(item)!)\n        }\n      }\n\n      let parent = toRaw(parents.get(id))\n\n      while (parent) {\n        const childrenIds = children.get(parent)!\n        const everySelected = childrenIds.every(cid => selected.get(toRaw(cid)) === 'on')\n        const noneSelected = childrenIds.every(cid => !selected.has(toRaw(cid)) || selected.get(toRaw(cid)) === 'off')\n\n        selected.set(parent, everySelected ? 'on' : noneSelected ? 'off' : 'indeterminate')\n\n        parent = toRaw(parents.get(parent))\n      }\n\n      // If mandatory and planned deselect results in no selected\n      // items then we can't do it, so return original state\n      if (mandatory && !value) {\n        const on = Array.from(selected.entries())\n          .reduce((arr, [key, value]) => {\n            if (value === 'on') arr.push(key)\n            return arr\n          }, [] as unknown[])\n        if (on.length === 0) return original\n      }\n\n      return selected\n    },\n    in: (v, children, parents) => {\n      let map = new Map()\n\n      for (const id of (v || [])) {\n        map = strategy.select({\n          id,\n          value: true,\n          selected: map,\n          children,\n          parents,\n        })\n      }\n\n      return map\n    },\n    out: (v, children) => {\n      const arr = []\n\n      for (const [key, value] of v.entries()) {\n        if (value === 'on' && !children.has(key)) arr.push(key)\n      }\n\n      return arr\n    },\n  }\n\n  return strategy\n}\n"]},"metadata":{},"sourceType":"module"}