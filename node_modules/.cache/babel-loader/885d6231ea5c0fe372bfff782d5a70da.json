{"ast":null,"code":"// Types\nconst Refs = Symbol('Forwarded refs');\n/** Omit properties starting with P */\n\n/** Omit keyof $props from T */\n\nfunction getDescriptor(obj, key) {\n  let currentObj = obj;\n\n  while (currentObj) {\n    const descriptor = Reflect.getOwnPropertyDescriptor(currentObj, key);\n    if (descriptor) return descriptor;\n    currentObj = Object.getPrototypeOf(currentObj);\n  }\n\n  return undefined;\n}\n\nexport function forwardRefs(target) {\n  for (var _len = arguments.length, refs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    refs[_key - 1] = arguments[_key];\n  }\n\n  target[Refs] = refs;\n  return new Proxy(target, {\n    get(target, key) {\n      if (Reflect.has(target, key)) {\n        return Reflect.get(target, key);\n      } // Skip internal properties\n\n\n      if (typeof key === 'symbol' || key.startsWith('$') || key.startsWith('__')) return;\n\n      for (const ref of refs) {\n        if (ref.value && Reflect.has(ref.value, key)) {\n          const val = Reflect.get(ref.value, key);\n          return typeof val === 'function' ? val.bind(ref.value) : val;\n        }\n      }\n    },\n\n    has(target, key) {\n      if (Reflect.has(target, key)) {\n        return true;\n      } // Skip internal properties\n\n\n      if (typeof key === 'symbol' || key.startsWith('$') || key.startsWith('__')) return false;\n\n      for (const ref of refs) {\n        if (ref.value && Reflect.has(ref.value, key)) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n\n    set(target, key, value) {\n      if (Reflect.has(target, key)) {\n        return Reflect.set(target, key, value);\n      } // Skip internal properties\n\n\n      if (typeof key === 'symbol' || key.startsWith('$') || key.startsWith('__')) return false;\n\n      for (const ref of refs) {\n        if (ref.value && Reflect.has(ref.value, key)) {\n          return Reflect.set(ref.value, key, value);\n        }\n      }\n\n      return false;\n    },\n\n    getOwnPropertyDescriptor(target, key) {\n      const descriptor = Reflect.getOwnPropertyDescriptor(target, key);\n      if (descriptor) return descriptor; // Skip internal properties\n\n      if (typeof key === 'symbol' || key.startsWith('$') || key.startsWith('__')) return; // Check each ref's own properties\n\n      for (const ref of refs) {\n        if (!ref.value) continue;\n        const descriptor = getDescriptor(ref.value, key) ?? ('_' in ref.value ? getDescriptor(ref.value._?.setupState, key) : undefined);\n        if (descriptor) return descriptor;\n      } // Recursive search up each ref's prototype\n\n\n      for (const ref of refs) {\n        const childRefs = ref.value && ref.value[Refs];\n        if (!childRefs) continue;\n        const queue = childRefs.slice();\n\n        while (queue.length) {\n          const ref = queue.shift();\n          const descriptor = getDescriptor(ref.value, key);\n          if (descriptor) return descriptor;\n          const childRefs = ref.value && ref.value[Refs];\n          if (childRefs) queue.push(...childRefs);\n        }\n      }\n\n      return undefined;\n    }\n\n  });\n}","map":{"version":3,"mappings":"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","names":["Refs","Symbol","getDescriptor","obj","key","currentObj","descriptor","Reflect","getOwnPropertyDescriptor","Object","getPrototypeOf","undefined","forwardRefs","target","refs","_key","arguments","Proxy","get","has","startsWith","ref","value","val","bind","set","_","setupState","childRefs","queue","slice","length","shift","push"],"sources":["../../src/composables/forwardRefs.ts"],"sourcesContent":["// Types\nimport type { ComponentOptionsBase, ComponentPublicInstance, Ref, UnwrapRef } from 'vue'\nimport type { UnionToIntersection } from '@/util'\n\nconst Refs = Symbol('Forwarded refs')\n\n/** Omit properties starting with P */\ntype OmitPrefix<\n  T,\n  P extends string,\n  E = Extract<keyof T, `${P}${any}`>,\n> = [E] extends [never] ? T : Omit<T, `${P}${any}`>\ntype OmitPrivate<T> = OmitPrefix<T, '$'>\n\n/** Omit keyof $props from T */\ntype OmitProps<T> = T extends { $props: any } ? Omit<T, keyof T['$props']> : T\n\nfunction getDescriptor (obj: any, key: PropertyKey) {\n  let currentObj = obj\n  while (currentObj) {\n    const descriptor = Reflect.getOwnPropertyDescriptor(currentObj, key)\n    if (descriptor) return descriptor\n    currentObj = Object.getPrototypeOf(currentObj)\n  }\n  return undefined\n}\n\nexport function forwardRefs<\n  T extends {},\n  U extends Ref<HTMLElement | Omit<ComponentPublicInstance, '$emit' | '$slots'> | undefined>[],\n  UU = { [K in keyof U]: NonNullable<UnwrapRef<U[K]>> }[number],\n  UC = { [K in keyof U]: OmitPrivate<OmitProps<NonNullable<UnwrapRef<U[K]>>>> }[number],\n  R = T & UnionToIntersection<UC> & {\n    _allExposed: T | (\n      UU extends { $options: infer O }\n        ? O extends ComponentOptionsBase<any, infer E, any, any, any, any, any, any>\n          ? E\n          : never\n        : never\n    )\n  }\n> (target: T, ...refs: U): R {\n  (target as any)[Refs] = refs\n\n  return new Proxy(target, {\n    get (target, key) {\n      if (Reflect.has(target, key)) {\n        return Reflect.get(target, key)\n      }\n\n      // Skip internal properties\n      if (typeof key === 'symbol' || key.startsWith('$') || key.startsWith('__')) return\n\n      for (const ref of refs) {\n        if (ref.value && Reflect.has(ref.value, key)) {\n          const val = Reflect.get(ref.value, key)\n          return typeof val === 'function'\n            ? val.bind(ref.value)\n            : val\n        }\n      }\n    },\n    has (target, key) {\n      if (Reflect.has(target, key)) {\n        return true\n      }\n\n      // Skip internal properties\n      if (typeof key === 'symbol' || key.startsWith('$') || key.startsWith('__')) return false\n\n      for (const ref of refs) {\n        if (ref.value && Reflect.has(ref.value, key)) {\n          return true\n        }\n      }\n      return false\n    },\n    set (target, key, value) {\n      if (Reflect.has(target, key)) {\n        return Reflect.set(target, key, value)\n      }\n\n      // Skip internal properties\n      if (typeof key === 'symbol' || key.startsWith('$') || key.startsWith('__')) return false\n\n      for (const ref of refs) {\n        if (ref.value && Reflect.has(ref.value, key)) {\n          return Reflect.set(ref.value, key, value)\n        }\n      }\n\n      return false\n    },\n    getOwnPropertyDescriptor (target, key) {\n      const descriptor = Reflect.getOwnPropertyDescriptor(target, key)\n      if (descriptor) return descriptor\n\n      // Skip internal properties\n      if (typeof key === 'symbol' || key.startsWith('$') || key.startsWith('__')) return\n\n      // Check each ref's own properties\n      for (const ref of refs) {\n        if (!ref.value) continue\n        const descriptor = getDescriptor(ref.value, key) ?? ('_' in ref.value ? getDescriptor(ref.value._?.setupState, key) : undefined)\n        if (descriptor) return descriptor\n      }\n\n      // Recursive search up each ref's prototype\n      for (const ref of refs) {\n        const childRefs = ref.value && (ref.value as any)[Refs]\n        if (!childRefs) continue\n        const queue = childRefs.slice()\n        while (queue.length) {\n          const ref = queue.shift()\n          const descriptor = getDescriptor(ref.value, key)\n          if (descriptor) return descriptor\n          const childRefs = ref.value && (ref.value as any)[Refs]\n          if (childRefs) queue.push(...childRefs)\n        }\n      }\n\n      return undefined\n    },\n  }) as any\n}\n"]},"metadata":{},"sourceType":"module"}