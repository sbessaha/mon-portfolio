{"ast":null,"code":"/* eslint-disable max-statements */\n// Composables\nimport { makeElevationProps } from \"../../composables/elevation.mjs\";\nimport { makeRoundedProps } from \"../../composables/rounded.mjs\";\nimport { useRtl } from \"../../composables/rtl.mjs\"; // Utilities\n\nimport { clamp, createRange, propsFactory } from \"../../util/index.mjs\";\nimport { computed, provide, ref, toRef } from 'vue'; // Types\n\nexport const VSliderSymbol = Symbol.for('vuetify:v-slider');\nexport function getOffset(e, el, direction) {\n  const vertical = direction === 'vertical';\n  const rect = el.getBoundingClientRect();\n  const touch = 'touches' in e ? e.touches[0] : e;\n  return vertical ? touch.clientY - (rect.top + rect.height / 2) : touch.clientX - (rect.left + rect.width / 2);\n}\n\nfunction getPosition(e, position) {\n  if ('touches' in e && e.touches.length) return e.touches[0][position];else if ('changedTouches' in e && e.changedTouches.length) return e.changedTouches[0][position];else return e[position];\n}\n\nexport const makeSliderProps = propsFactory({\n  disabled: Boolean,\n  error: Boolean,\n  readonly: Boolean,\n  max: {\n    type: [Number, String],\n    default: 100\n  },\n  min: {\n    type: [Number, String],\n    default: 0\n  },\n  step: {\n    type: [Number, String],\n    default: 0\n  },\n  thumbColor: String,\n  thumbLabel: {\n    type: [Boolean, String],\n    default: undefined,\n    validator: v => typeof v === 'boolean' || v === 'always'\n  },\n  thumbSize: {\n    type: [Number, String],\n    default: 20\n  },\n  showTicks: {\n    type: [Boolean, String],\n    default: false,\n    validator: v => typeof v === 'boolean' || v === 'always'\n  },\n  ticks: {\n    type: [Array, Object]\n  },\n  tickSize: {\n    type: [Number, String],\n    default: 2\n  },\n  color: String,\n  trackColor: String,\n  trackFillColor: String,\n  trackSize: {\n    type: [Number, String],\n    default: 4\n  },\n  direction: {\n    type: String,\n    default: 'horizontal',\n    validator: v => ['vertical', 'horizontal'].includes(v)\n  },\n  reverse: Boolean,\n  ...makeRoundedProps(),\n  ...makeElevationProps({\n    elevation: 2\n  })\n}, 'slider');\nexport const useSlider = _ref => {\n  let {\n    props,\n    handleSliderMouseUp,\n    handleMouseMove,\n    getActiveThumb\n  } = _ref;\n  const {\n    isRtl\n  } = useRtl();\n  const isReversed = computed(() => isRtl.value !== props.reverse);\n  const horizontalDirection = computed(() => {\n    let hd = isRtl.value ? 'rtl' : 'ltr';\n\n    if (props.reverse) {\n      hd = hd === 'rtl' ? 'ltr' : 'rtl';\n    }\n\n    return hd;\n  });\n  const min = computed(() => parseFloat(props.min));\n  const max = computed(() => parseFloat(props.max));\n  const step = computed(() => props.step > 0 ? parseFloat(props.step) : 0);\n  const decimals = computed(() => {\n    const trimmedStep = step.value.toString().trim();\n    return trimmedStep.includes('.') ? trimmedStep.length - trimmedStep.indexOf('.') - 1 : 0;\n  });\n  const thumbSize = computed(() => parseInt(props.thumbSize, 10));\n  const tickSize = computed(() => parseInt(props.tickSize, 10));\n  const trackSize = computed(() => parseInt(props.trackSize, 10));\n  const numTicks = computed(() => (max.value - min.value) / step.value);\n  const disabled = toRef(props, 'disabled');\n  const vertical = computed(() => props.direction === 'vertical');\n  const thumbColor = computed(() => props.error || props.disabled ? undefined : props.thumbColor ?? props.color);\n  const trackColor = computed(() => props.error || props.disabled ? undefined : props.trackColor ?? props.color);\n  const trackFillColor = computed(() => props.error || props.disabled ? undefined : props.trackFillColor ?? props.color);\n  const mousePressed = ref(false);\n  const startOffset = ref(0);\n  const trackContainerRef = ref();\n  const activeThumbRef = ref();\n\n  function roundValue(value) {\n    if (step.value <= 0) return value;\n    const clamped = clamp(value, min.value, max.value);\n    const offset = min.value % step.value;\n    const newValue = Math.round((clamped - offset) / step.value) * step.value + offset;\n    return parseFloat(Math.min(newValue, max.value).toFixed(decimals.value));\n  }\n\n  function parseMouseMove(e) {\n    var _trackContainerRef$va;\n\n    const vertical = props.direction === 'vertical';\n    const start = vertical ? 'top' : 'left';\n    const length = vertical ? 'height' : 'width';\n    const position = vertical ? 'clientY' : 'clientX';\n    const {\n      [start]: trackStart,\n      [length]: trackLength\n    } = (_trackContainerRef$va = trackContainerRef.value) == null ? void 0 : _trackContainerRef$va.$el.getBoundingClientRect();\n    const clickOffset = getPosition(e, position); // It is possible for left to be NaN, force to number\n\n    let clickPos = Math.min(Math.max((clickOffset - trackStart - startOffset.value) / trackLength, 0), 1) || 0;\n    if (vertical || isReversed.value) clickPos = 1 - clickPos;\n    return roundValue(min.value + clickPos * (max.value - min.value));\n  }\n\n  let thumbMoved = false;\n\n  const handleStop = e => {\n    if (!thumbMoved) {\n      startOffset.value = 0;\n      handleSliderMouseUp(parseMouseMove(e));\n    }\n\n    mousePressed.value = false;\n    thumbMoved = false;\n    startOffset.value = 0;\n  };\n\n  const handleStart = e => {\n    activeThumbRef.value = getActiveThumb(e);\n    if (!activeThumbRef.value) return;\n    activeThumbRef.value.focus();\n    mousePressed.value = true;\n\n    if (activeThumbRef.value.contains(e.target)) {\n      thumbMoved = true;\n      startOffset.value = getOffset(e, activeThumbRef.value, props.direction);\n    } else {\n      startOffset.value = 0;\n      handleMouseMove(parseMouseMove(e));\n    }\n  };\n\n  const moveListenerOptions = {\n    passive: true,\n    capture: true\n  };\n\n  function onMouseMove(e) {\n    thumbMoved = true;\n    handleMouseMove(parseMouseMove(e));\n  }\n\n  function onSliderMouseUp(e) {\n    e.stopPropagation();\n    e.preventDefault();\n    handleStop(e);\n    window.removeEventListener('mousemove', onMouseMove, moveListenerOptions);\n    window.removeEventListener('mouseup', onSliderMouseUp);\n  }\n\n  function onSliderTouchend(e) {\n    var _e$target;\n\n    handleStop(e);\n    window.removeEventListener('touchmove', onMouseMove, moveListenerOptions);\n    (_e$target = e.target) == null ? void 0 : _e$target.removeEventListener('touchend', onSliderTouchend);\n  }\n\n  function onSliderTouchstart(e) {\n    var _e$target2;\n\n    handleStart(e);\n    window.addEventListener('touchmove', onMouseMove, moveListenerOptions);\n    (_e$target2 = e.target) == null ? void 0 : _e$target2.addEventListener('touchend', onSliderTouchend, {\n      passive: false\n    });\n  }\n\n  function onSliderMousedown(e) {\n    e.preventDefault();\n    handleStart(e);\n    window.addEventListener('mousemove', onMouseMove, moveListenerOptions);\n    window.addEventListener('mouseup', onSliderMouseUp, {\n      passive: false\n    });\n  }\n\n  const position = val => {\n    const percentage = (val - min.value) / (max.value - min.value) * 100;\n    return clamp(isNaN(percentage) ? 0 : percentage, 0, 100);\n  };\n\n  const parsedTicks = computed(() => {\n    if (!props.ticks) {\n      return numTicks.value !== Infinity ? createRange(numTicks.value + 1).map(t => {\n        const value = min.value + t * step.value;\n        return {\n          value,\n          position: position(value)\n        };\n      }) : [];\n    }\n\n    if (Array.isArray(props.ticks)) return props.ticks.map(t => ({\n      value: t,\n      position: position(t),\n      label: t.toString()\n    }));\n    return Object.keys(props.ticks).map(key => ({\n      value: parseInt(key, 10),\n      position: position(parseInt(key, 10)),\n      label: props.ticks[key]\n    }));\n  });\n  const hasLabels = computed(() => parsedTicks.value.some(_ref2 => {\n    let {\n      label\n    } = _ref2;\n    return !!label;\n  }));\n  const data = {\n    activeThumbRef,\n    color: toRef(props, 'color'),\n    decimals,\n    disabled,\n    direction: toRef(props, 'direction'),\n    elevation: toRef(props, 'elevation'),\n    hasLabels,\n    horizontalDirection,\n    isReversed,\n    min,\n    max,\n    mousePressed,\n    numTicks,\n    onSliderMousedown,\n    onSliderTouchstart,\n    parsedTicks,\n    parseMouseMove,\n    position,\n    readonly: toRef(props, 'readonly'),\n    rounded: toRef(props, 'rounded'),\n    roundValue,\n    showTicks: toRef(props, 'showTicks'),\n    startOffset,\n    step,\n    thumbSize,\n    thumbColor,\n    thumbLabel: toRef(props, 'thumbLabel'),\n    ticks: toRef(props, 'ticks'),\n    tickSize,\n    trackColor,\n    trackContainerRef,\n    trackFillColor,\n    trackSize,\n    vertical\n  };\n  provide(VSliderSymbol, data);\n  return data;\n};","map":{"version":3,"mappings":"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","names":["makeElevationProps","makeRoundedProps","useRtl","clamp","createRange","propsFactory","computed","provide","ref","toRef","VSliderSymbol","Symbol","for","getOffset","e","el","direction","vertical","rect","getBoundingClientRect","touch","touches","clientY","top","height","clientX","left","width","getPosition","position","length","changedTouches","makeSliderProps","disabled","Boolean","error","readonly","max","type","Number","String","default","min","step","thumbColor","thumbLabel","undefined","validator","v","thumbSize","showTicks","ticks","Array","Object","tickSize","color","trackColor","trackFillColor","trackSize","includes","reverse","elevation","useSlider","_ref","props","handleSliderMouseUp","handleMouseMove","getActiveThumb","isRtl","isReversed","value","horizontalDirection","hd","parseFloat","decimals","trimmedStep","toString","trim","indexOf","parseInt","numTicks","mousePressed","startOffset","trackContainerRef","activeThumbRef","roundValue","clamped","offset","newValue","Math","round","toFixed","parseMouseMove","start","trackStart","trackLength","_trackContainerRef$va","$el","clickOffset","clickPos","thumbMoved","handleStop","handleStart","focus","contains","target","moveListenerOptions","passive","capture","onMouseMove","onSliderMouseUp","stopPropagation","preventDefault","window","removeEventListener","onSliderTouchend","onSliderTouchstart","addEventListener","onSliderMousedown","val","percentage","isNaN","parsedTicks","Infinity","map","t","isArray","label","keys","key","hasLabels","some","_ref2","data","rounded"],"sources":["../../../src/components/VSlider/slider.ts"],"sourcesContent":["/* eslint-disable max-statements */\n// Composables\nimport { makeElevationProps } from '@/composables/elevation'\nimport { makeRoundedProps } from '@/composables/rounded'\nimport { useRtl } from '@/composables/rtl'\n\n// Utilities\nimport { clamp, createRange, propsFactory } from '@/util'\nimport { computed, provide, ref, toRef } from 'vue'\n\n// Types\nimport type { ExtractPropTypes, InjectionKey, PropType, Ref } from 'vue'\nimport type { VSliderTrack } from './VSliderTrack'\n\ntype Tick = {\n  value: number\n  position: number\n  label?: string\n}\n\ntype SliderProvide = {\n  activeThumbRef: Ref<HTMLElement | undefined>\n  color: Ref<string | undefined>\n  decimals: Ref<number>\n  direction: Ref<'vertical' | 'horizontal'>\n  disabled: Ref<boolean | undefined>\n  elevation: Ref<number | string | undefined>\n  min: Ref<number>\n  max: Ref<number>\n  mousePressed: Ref<boolean>\n  numTicks: Ref<number>\n  onSliderMousedown: (e: MouseEvent) => void\n  onSliderTouchstart: (e: TouchEvent) => void\n  parseMouseMove: (e: MouseEvent | TouchEvent) => number\n  position: (val: number) => number\n  readonly: Ref<boolean | undefined>\n  rounded: Ref<boolean | number | string | undefined>\n  roundValue: (value: number) => number\n  thumbLabel: Ref<boolean | string | undefined>\n  showTicks: Ref<boolean | 'always'>\n  startOffset: Ref<number>\n  step: Ref<number>\n  thumbSize: Ref<number>\n  thumbColor: Ref<string | undefined>\n  trackColor: Ref<string | undefined>\n  trackFillColor: Ref<string | undefined>\n  trackSize: Ref<number>\n  ticks: Ref<number[] | Record<string, string> | undefined>\n  tickSize: Ref<number>\n  trackContainerRef: Ref<VSliderTrack | undefined>\n  vertical: Ref<boolean>\n  parsedTicks: Ref<Tick[]>\n  hasLabels: Ref<boolean>\n  isReversed: Ref<boolean>\n  horizontalDirection: Ref<'ltr' | 'rtl'>\n}\n\nexport const VSliderSymbol: InjectionKey<SliderProvide> = Symbol.for('vuetify:v-slider')\n\nexport function getOffset (e: MouseEvent | TouchEvent, el: HTMLElement, direction: string) {\n  const vertical = direction === 'vertical'\n  const rect = el.getBoundingClientRect()\n  const touch = 'touches' in e ? e.touches[0] : e\n  return vertical\n    ? touch.clientY - (rect.top + rect.height / 2)\n    : touch.clientX - (rect.left + rect.width / 2)\n}\n\nfunction getPosition (e: MouseEvent | TouchEvent, position: 'clientX' | 'clientY'): number {\n  if ('touches' in e && e.touches.length) return e.touches[0][position]\n  else if ('changedTouches' in e && e.changedTouches.length) return e.changedTouches[0][position]\n  else return (e as MouseEvent)[position]\n}\n\nexport const makeSliderProps = propsFactory({\n  disabled: Boolean,\n  error: Boolean,\n  readonly: Boolean,\n  max: {\n    type: [Number, String],\n    default: 100,\n  },\n  min: {\n    type: [Number, String],\n    default: 0,\n  },\n  step: {\n    type: [Number, String],\n    default: 0,\n  },\n  thumbColor: String,\n  thumbLabel: {\n    type: [Boolean, String] as PropType<boolean | 'always' | undefined>,\n    default: undefined,\n    validator: (v: any) => typeof v === 'boolean' || v === 'always',\n  },\n  thumbSize: {\n    type: [Number, String],\n    default: 20,\n  },\n  showTicks: {\n    type: [Boolean, String] as PropType<boolean | 'always'>,\n    default: false,\n    validator: (v: any) => typeof v === 'boolean' || v === 'always',\n  },\n  ticks: {\n    type: [Array, Object] as PropType<number[] | Record<number, string>>,\n  },\n  tickSize: {\n    type: [Number, String],\n    default: 2,\n  },\n  color: String,\n  trackColor: String,\n  trackFillColor: String,\n  trackSize: {\n    type: [Number, String],\n    default: 4,\n  },\n  direction: {\n    type: String as PropType<'horizontal' | 'vertical'>,\n    default: 'horizontal',\n    validator: (v: any) => ['vertical', 'horizontal'].includes(v),\n  },\n  reverse: Boolean,\n\n  ...makeRoundedProps(),\n  ...makeElevationProps({\n    elevation: 2,\n  }),\n}, 'slider')\n\ntype SliderProps = ExtractPropTypes<ReturnType<typeof makeSliderProps>>\n\nexport const useSlider = ({\n  props,\n  handleSliderMouseUp,\n  handleMouseMove,\n  getActiveThumb,\n}: {\n  props: SliderProps\n  handleSliderMouseUp: (v: number) => void\n  handleMouseMove: (v: number) => void\n  getActiveThumb: (e: MouseEvent | TouchEvent) => HTMLElement\n}) => {\n  const { isRtl } = useRtl()\n  const isReversed = computed(() => isRtl.value !== props.reverse)\n  const horizontalDirection = computed(() => {\n    let hd: 'ltr' | 'rtl' = isRtl.value ? 'rtl' : 'ltr'\n\n    if (props.reverse) {\n      hd = hd === 'rtl' ? 'ltr' : 'rtl'\n    }\n\n    return hd\n  })\n  const min = computed(() => parseFloat(props.min))\n  const max = computed(() => parseFloat(props.max))\n  const step = computed(() => props.step > 0 ? parseFloat(props.step) : 0)\n  const decimals = computed(() => {\n    const trimmedStep = step.value.toString().trim()\n    return trimmedStep.includes('.')\n      ? (trimmedStep.length - trimmedStep.indexOf('.') - 1)\n      : 0\n  })\n\n  const thumbSize = computed(() => parseInt(props.thumbSize, 10))\n  const tickSize = computed(() => parseInt(props.tickSize, 10))\n  const trackSize = computed(() => parseInt(props.trackSize, 10))\n  const numTicks = computed(() => (max.value - min.value) / step.value)\n  const disabled = toRef(props, 'disabled')\n  const vertical = computed(() => props.direction === 'vertical')\n\n  const thumbColor = computed(() => props.error || props.disabled ? undefined : props.thumbColor ?? props.color)\n  const trackColor = computed(() => props.error || props.disabled ? undefined : props.trackColor ?? props.color)\n  const trackFillColor = computed(() => props.error || props.disabled ? undefined : props.trackFillColor ?? props.color)\n\n  const mousePressed = ref(false)\n\n  const startOffset = ref(0)\n  const trackContainerRef = ref<VSliderTrack | undefined>()\n  const activeThumbRef = ref<HTMLElement | undefined>()\n\n  function roundValue (value: number) {\n    if (step.value <= 0) return value\n\n    const clamped = clamp(value, min.value, max.value)\n    const offset = min.value % step.value\n    const newValue = Math.round((clamped - offset) / step.value) * step.value + offset\n\n    return parseFloat(Math.min(newValue, max.value).toFixed(decimals.value))\n  }\n\n  function parseMouseMove (e: MouseEvent | TouchEvent): number {\n    const vertical = props.direction === 'vertical'\n    const start = vertical ? 'top' : 'left'\n    const length = vertical ? 'height' : 'width'\n    const position = vertical ? 'clientY' : 'clientX'\n\n    const {\n      [start]: trackStart,\n      [length]: trackLength,\n    } = trackContainerRef.value?.$el.getBoundingClientRect()\n    const clickOffset = getPosition(e, position)\n\n    // It is possible for left to be NaN, force to number\n    let clickPos = Math.min(Math.max((clickOffset - trackStart - startOffset.value) / trackLength, 0), 1) || 0\n\n    if (vertical || isReversed.value) clickPos = 1 - clickPos\n\n    return roundValue(min.value + clickPos * (max.value - min.value))\n  }\n\n  let thumbMoved = false\n\n  const handleStop = (e: MouseEvent | TouchEvent) => {\n    if (!thumbMoved) {\n      startOffset.value = 0\n      handleSliderMouseUp(parseMouseMove(e))\n    }\n\n    mousePressed.value = false\n    thumbMoved = false\n    startOffset.value = 0\n  }\n\n  const handleStart = (e: MouseEvent | TouchEvent) => {\n    activeThumbRef.value = getActiveThumb(e)\n\n    if (!activeThumbRef.value) return\n\n    activeThumbRef.value.focus()\n    mousePressed.value = true\n\n    if (activeThumbRef.value.contains(e.target as Node)) {\n      thumbMoved = true\n      startOffset.value = getOffset(e, activeThumbRef.value, props.direction)\n    } else {\n      startOffset.value = 0\n      handleMouseMove(parseMouseMove(e))\n    }\n  }\n\n  const moveListenerOptions = { passive: true, capture: true }\n\n  function onMouseMove (e: MouseEvent | TouchEvent) {\n    thumbMoved = true\n    handleMouseMove(parseMouseMove(e))\n  }\n\n  function onSliderMouseUp (e: MouseEvent) {\n    e.stopPropagation()\n    e.preventDefault()\n\n    handleStop(e)\n\n    window.removeEventListener('mousemove', onMouseMove, moveListenerOptions)\n    window.removeEventListener('mouseup', onSliderMouseUp)\n  }\n\n  function onSliderTouchend (e: TouchEvent) {\n    handleStop(e)\n\n    window.removeEventListener('touchmove', onMouseMove, moveListenerOptions)\n    e.target?.removeEventListener('touchend', onSliderTouchend as EventListener)\n  }\n\n  function onSliderTouchstart (e: TouchEvent) {\n    handleStart(e)\n\n    window.addEventListener('touchmove', onMouseMove, moveListenerOptions)\n    e.target?.addEventListener('touchend', onSliderTouchend as EventListener, { passive: false })\n  }\n\n  function onSliderMousedown (e: MouseEvent) {\n    e.preventDefault()\n\n    handleStart(e)\n\n    window.addEventListener('mousemove', onMouseMove, moveListenerOptions)\n    window.addEventListener('mouseup', onSliderMouseUp, { passive: false })\n  }\n\n  const position = (val: number) => {\n    const percentage = (val - min.value) / (max.value - min.value) * 100\n    return clamp(isNaN(percentage) ? 0 : percentage, 0, 100)\n  }\n\n  const parsedTicks = computed<Tick[]>(() => {\n    if (!props.ticks) {\n      return numTicks.value !== Infinity ? createRange(numTicks.value + 1).map(t => {\n        const value = min.value + (t * step.value)\n        return {\n          value,\n          position: position(value),\n        }\n      }) : []\n    }\n    if (Array.isArray(props.ticks)) return props.ticks.map(t => ({ value: t, position: position(t), label: t.toString() }))\n    return Object.keys(props.ticks).map(key => ({\n      value: parseInt(key, 10),\n      position: position(parseInt(key, 10)),\n      label: (props.ticks as Record<string, string>)[key],\n    }))\n  })\n\n  const hasLabels = computed(() => parsedTicks.value.some(({ label }) => !!label))\n\n  const data: SliderProvide = {\n    activeThumbRef,\n    color: toRef(props, 'color'),\n    decimals,\n    disabled,\n    direction: toRef(props, 'direction'),\n    elevation: toRef(props, 'elevation'),\n    hasLabels,\n    horizontalDirection,\n    isReversed,\n    min,\n    max,\n    mousePressed,\n    numTicks,\n    onSliderMousedown,\n    onSliderTouchstart,\n    parsedTicks,\n    parseMouseMove,\n    position,\n    readonly: toRef(props, 'readonly'),\n    rounded: toRef(props, 'rounded'),\n    roundValue,\n    showTicks: toRef(props, 'showTicks'),\n    startOffset,\n    step,\n    thumbSize,\n    thumbColor,\n    thumbLabel: toRef(props, 'thumbLabel'),\n    ticks: toRef(props, 'ticks'),\n    tickSize,\n    trackColor,\n    trackContainerRef,\n    trackFillColor,\n    trackSize,\n    vertical,\n  }\n\n  provide(VSliderSymbol, data)\n\n  return data\n}\n"]},"metadata":{},"sourceType":"module"}